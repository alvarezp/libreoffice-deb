--- oo_1.0.1_src/config_office/set_soenv.1.bak	2002-09-19 10:20:05.000000000 +0200
+++ oo_1.0.1_src/config_office/set_soenv.1	2002-09-19 10:20:31.000000000 +0200
@@ -389,6 +390,17 @@
       $JRETOOLKITDIR  = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."ppc".$ds."classic";
       $JRETHREADDIR   = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."ppc".$ds."native_threads";
    }
+   elsif ($machine_type eq "s390")
+   {  print "Setting Linux S/390 specific values... ";
+      $outfile        = "LinuxS390Env.Set";
+      $CPU            = "3";
+      $CPUNAME        = "S390";
+      $DLLSUFFIX      = "l3";
+      $OUTPATH        = "unxlngs390";
+      $JRELIBDIR      = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."s390";
+      $JRETOOLKITDIR  = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."s390".$ds."client";
+      $JRETHREADDIR   = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."s390".$ds."native_threads";
+       }
    elsif ($machine_type eq "alpha") 
    {  print "Setting Linux Alpha specific values... ";
       $outfile        = "LinuxAlphaEnv.Set"; 
diff -urN oo_1.0.1_src/solenv/inc.bak/unx.mk oo_1.0.1_src/solenv/inc/unx.mk
--- oo_1.0.1_src/solenv/inc.bak/unx.mk	2002-09-19 10:05:25.000000000 +0200
+++ oo_1.0.1_src/solenv/inc/unx.mk	2002-09-19 10:07:35.000000000 +0200
@@ -124,6 +124,10 @@
 .INCLUDE : unxlngppc4.mk 
 .ENDIF 
  
+.IF "$(COM)$(CVER)$(OS)$(CPU)$(GLIBC)" == "GCCC300LINUX32REDHAT60" 
+.INCLUDE : unxlngs3904.mk 
+.ENDIF 
+ 
 .IF "$(COM)$(OS)$(CPU)$(GLIBC)" == "GCCLINUXR2REDHAT60"
 .INCLUDE : unxlngr.mk
 .ENDIF
diff -urN oo_1.0.1_src/solenv/inc.bak/unxlngs3904.mk oo_1.0.1_src/solenv/inc/unxlngs3904.mk
--- oo_1.0.1_src/solenv/inc.bak/unxlngs3904.mk	1970-01-01 01:00:00.000000000 +0100
+++ oo_1.0.1_src/solenv/inc/unxlngs3904.mk	2002-09-19 10:08:47.000000000 +0200
@@ -0,0 +1,228 @@
+#*************************************************************************
+#
+#   $RCSfile: unxlngs3904.mk,v $
+#
+#   $Revision: 1.1.2.3 $
+#
+#   last change: $Author: khendricks $ $Date: 2002/06/07 14:11:58 $
+#
+#   The Contents of this file are made available subject to the terms of
+#   either of the following licenses
+#
+#          - GNU Lesser General Public License Version 2.1
+#          - Sun Industry Standards Source License Version 1.1
+#
+#   Sun Microsystems Inc., October, 2000
+#
+#   GNU Lesser General Public License Version 2.1
+#   =============================================
+#   Copyright 2000 by Sun Microsystems, Inc.
+#   901 San Antonio Road, Palo Alto, CA 94303, USA
+#
+#   This library is free software; you can redistribute it and/or
+#   modify it under the terms of the GNU Lesser General Public
+#   License version 2.1, as published by the Free Software Foundation.
+#
+#   This library is distributed in the hope that it will be useful,
+#   but WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#   Lesser General Public License for more details.
+#
+#   You should have received a copy of the GNU Lesser General Public
+#   License along with this library; if not, write to the Free Software
+#   Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+#   MA  02111-1307  USA
+#
+#
+#   Sun Industry Standards Source License Version 1.1
+#   =================================================
+#   The contents of this file are subject to the Sun Industry Standards
+#   Source License Version 1.1 (the "License"); You may not use this file
+#   except in compliance with the License. You may obtain a copy of the
+#   License at http://www.openoffice.org/license.html.
+#
+#   Software provided under this License is provided on an "AS IS" basis,
+#   WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+#   WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+#   MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+#   See the License for the specific provisions governing your rights and
+#   obligations concerning the Software.
+#
+#   The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+#
+#   Copyright: 2000 by Sun Microsystems, Inc.
+#
+#   All Rights Reserved.
+#
+#   Contributor(s): _______________________________________
+#
+#
+#
+#*************************************************************************
+
+# mk file for linux s390 using gcc 3.X
+ASM=
+AFLAGS=
+
+SOLAR_JAVA=TRUE
+JAVAFLAGSDEBUG=-g
+
+# filter for supressing verbose messages from linker
+#not needed at the moment
+#LINKOUTPUT_FILTER=" |& $(SOLARENV)$/bin$/msg_filter"
+
+# _PTHREADS is needed for the stl
+CDEFS+=-DGLIBC=2 -D_PTHREADS -D_REENTRANT -DNEW_SOLAR -D_USE_NAMESPACE=1 -DSTLPORT_VERSION=400
+
+# this is a platform with JAVA support
+.IF "$(SOLAR_JAVA)"!=""
+JAVADEF=-DSOLAR_JAVA
+.IF "$(debug)"==""
+JAVA_RUNTIME=-ljava
+.ELSE
+JAVA_RUNTIME=-ljava_g
+.ENDIF
+.ENDIF 
+
+# name of C++ Compiler
+CC=$(CXXCOMP)
+# name of C Compiler
+cc=$(CCCOMP)
+
+# flags for C and C++ Compiler
+# do not use standard header search paths
+# if installed elsewhere
+.IF "$(BUILD_SOSL)"!=""
+CFLAGS= 
+.ENDIF
+CFLAGS+=-fsigned-char -fmessage-length=0 -c $(INCLUDE)
+
+# flags for the C++ Compiler
+CFLAGSCC= -fsigned-char -pipe 
+
+# Flags for enabling exception handling
+CFLAGSEXCEPTIONS=-fexceptions -fno-enforce-eh-specs
+
+# Flags for disabling exception handling
+CFLAGS_NO_EXCEPTIONS=-fno-exceptions
+
+# -fpermissive should be removed as soon as possible
+#CFLAGSCXX= -fsigned-char -pipe -fno-for-scope -fpermissive -fno-rtti 
+CFLAGSCXX= -fsigned-char -pipe -fno-for-scope -fpermissive
+
+
+# Compiler flags for compiling static object in single threaded environment with graphical user interface
+CFLAGSOBJGUIST=-fPIC
+# Compiler flags for compiling static object in single threaded environment with character user interface
+CFLAGSOBJCUIST=-fPIC
+# Compiler flags for compiling static object in multi threaded environment with graphical user interface
+CFLAGSOBJGUIMT=-fPIC
+# Compiler flags for compiling static object in multi threaded environment with character user interface
+CFLAGSOBJCUIMT=-fPIC
+# Compiler flags for compiling shared object in multi threaded environment with graphical user interface
+CFLAGSSLOGUIMT=-fPIC
+# Compiler flags for compiling shared object in multi threaded environment with character user interface
+CFLAGSSLOCUIMT=-fPIC
+
+# Compiler flags for profiling
+CFLAGSPROF=
+
+# Compiler flags for debugging
+CFLAGSDEBUG=-g
+CFLAGSDBGUTIL=
+
+# Compiler flags for enabling optimazations
+#CFLAGSOPT=-O2 -fno-schedule-insns -fno-strict-aliasing -fno-schedule-insns2
+CFLAGSOPT=-O2 -fno-strict-aliasing
+
+# Compiler flags for disabling optimazations
+# don't change - require dto work around optimization bugs
+CFLAGSNOOPT=-O0
+
+# Compiler flags for discibing the output path
+CFLAGSOUTOBJ=-o
+
+# Enable all warnings
+CFLAGSWALL=-Wall
+
+# Set default warn level
+CFLAGSDFLTWARN=-w
+
+# switches for dynamic and static linking
+STATIC		= -Wl,-Bstatic
+DYNAMIC		= -Wl,-Bdynamic
+
+# name of linker
+LINK=$(CXXCOMP)
+# default linker flags
+LINKFLAGS=
+
+# linker flags for linking applications
+LINKFLAGSAPPGUI= -Wl,-export-dynamic -Wl,--noinhibit-exec
+LINKFLAGSAPPCUI= -Wl,-export-dynamic -Wl,--noinhibit-exec
+
+# linker flags for linking shared libraries
+LINKFLAGSSHLGUI= -shared
+LINKFLAGSSHLCUI= -shared
+
+LINKFLAGSTACK=
+LINKFLAGSPROF=
+LINKFLAGSDEBUG=-g
+LINKFLAGSOPT=
+
+.IF "$(NO_BSYMBOLIC)"==""
+.IF "$(PRJNAME)" != "envtest"
+LINKFLAGSSHLGUI+=-Wl,-Bsymbolic
+LINKFLAGSSHLCUI+=-Wl,-Bsymbolic
+.ENDIF
+.ENDIF				# "$(NO_BSYMBOLIC)"==""
+
+LINKVERSIONMAPFLAG=-Wl,--version-script
+
+SONAME_SWITCH=-Wl,-h
+
+# Sequence of libs does matter !
+
+STDLIBCPP=-lstdc++
+
+# default objectfilenames to link
+STDOBJGUI=
+STDSLOGUI=
+STDOBJCUI=
+STDSLOCUI=
+
+# libraries for linking applications
+STDLIBCUIST=-ldl -lm
+STDLIBGUIMT=-lX11 -ldl -lpthread -lm
+STDLIBCUIMT=-ldl -lpthread -lm
+STDLIBGUIST=-lX11 -ldl -lm
+# libraries for linking shared libraries
+STDSHLGUIMT=-lX11 -lXext -ldl -lpthread -lm
+STDSHLCUIMT=-ldl -lpthread -lm
+
+LIBSTLPORT=$(DYNAMIC) -lstlport_gcc -lstdc++
+LIBSTLPORTST=$(STATIC) -lstlport_gcc $(DYNAMIC)
+
+#FILLUPARC=$(STATIC) -lsupc++ $(DYNAMIC)
+
+# name of library manager
+LIBMGR=ar
+LIBFLAGS=-r
+
+# tool for generating import libraries
+IMPLIB=
+IMPLIBFLAGS=
+
+MAPSYM=
+MAPSYMFLAGS=
+
+RC=irc
+RCFLAGS=-fo$@ $(RCFILES)
+RCLINK=
+RCLINKFLAGS=
+RCSETVERSION=
+
+# platform specific identifier for shared libs
+DLLPOSTFIX=l3
+DLLPRE=lib
+DLLPOST=.so
--- oo_1.0.1_src/psprint/source/fontsubset/sft.h.bak	2002-09-19 10:31:13.000000000 +0200
+++ oo_1.0.1_src/psprint/source/fontsubset/sft.h	2002-09-15 21:57:35.000000000 +0200
@@ -122,6 +122,12 @@
 #endif
 #endif
 
+#if defined(__s390__)
+#ifndef G_BIG_ENDIAN
+#define G_BIG_ENDIAN
+#endif
+#endif
+
 #ifdef __i386
 #ifndef G_LITTLE_ENDIAN
 #define G_LITTLE_ENDIAN
--- oo_1.0.1_src/tools/inc/solar.h.bak	2002-09-19 10:33:20.000000000 +0200
+++ oo_1.0.1_src/tools/inc/solar.h	2002-09-19 10:33:41.000000000 +0200
@@ -416,6 +416,7 @@
 #define SYSTEM_UNXBSDS		25
 #define SYSTEM_UNXLNXR		26
 #define SYSTEM_UNXBSDP		27
+#define SYSTEM_UNXLNX3         28
 
 #if defined WNT
   #define __DLLEXTENSION "mi"
@@ -454,6 +455,9 @@
 #elif defined LINUX && defined POWERPC
   #define __DLLEXTENSION "lp.so"
   #define SYSTEM_ID 		SYSTEM_UNXLNXP
+#elif defined LINUX && defined S390
+  #define __DLLEXTENSION "l3.so"
+  #define SYSTEM_ID 		SYSTEM_UNXLNX3
 #elif defined LINUX && defined ARM32
   #define __DLLEXTENSION "lr.so"
   #define SYSTEM_ID 	SYSTEM_UNXLNXR
--- oo_1.0.1_src/setup2/source/custom/jvmsetup/unx/jvmscan.cxx.bak	2002-09-19 10:39:15.000000000 +0200
+++ oo_1.0.1_src/setup2/source/custom/jvmsetup/unx/jvmscan.cxx	2002-09-19 10:39:47.000000000 +0200
@@ -111,6 +111,8 @@
 #define ARCH "ppc"
 #elif defined (MIPS)
 #define ARCH "mips"
+#elif defined (S390)
+#define ARCH "s390"
 #else
 #error unknown plattform
 #endif
--- oo_1.0.1_src/bridges/prj/build.lst.bak	2002-09-19 10:49:40.000000000 +0200
+++ oo_1.0.1_src/bridges/prj/build.lst	2002-09-19 10:50:20.000000000 +0200
@@ -11,6 +11,7 @@
 br	bridges\source\cpp_uno\gcc2_freebsd_intel	nmake	-	u	br_gccfi br_unotypes NULL
 br	bridges\source\cpp_uno\gcc2_linux_powerpc	nmake	-	u	br_gcclp br_unotypes NULL
 br	bridges\source\cpp_uno\gcc3_linux_powerpc	nmake	-	u	br_gcc3lp br_unotypes NULL
+br	bridges\source\cpp_uno\gcc3_linux_s390		nmake	-	u	br_gcc3l3 br_unotypes NULL
 br	bridges\source\cpp_uno\gcc2_macosx_powerpc			nmake	-	u	br_gccmacoxp br_unotypes NULL
 br	bridges\source\cpp_uno\cc50_solaris_sparc			nmake	-	u	br_cc50sols br_unotypes NULL
 br	bridges\source\cpp_uno\cc50_solaris_intel			nmake	-	u	br_cc50soli br_unotypes NULL
diff -urN oo_1.0.1_src/readlicense/source/readme/unxlngs390.bak/README oo_1.0.1_src/readlicense/source/readme/unxlngs390/README
--- oo_1.0.1_src/readlicense/source/readme/unxlngs390.bak/README	1970-01-01 01:00:00.000000000 +0100
+++ oo_1.0.1_src/readlicense/source/readme/unxlngs390/README	2002-09-28 18:50:53.000000000 +0200
@@ -0,0 +1,208 @@
+
+Welcome
+
+Last updated 2002 April 24
+
+OpenOffice.org 1.0 ReadMe
+
+For latest updates to this readme file, see www.openoffice.org/welcome/readme.html
+
+Dear User
+
+This file contains important information about the OpenOffice.org 1.0 office suite. Please read this information very carefully before starting work.
+The OpenOffice.org community, responsible for the development of this product, would like to invite you to participate as a community member. As a new user, you can check out the OpenOffice.org site with helpful user information at http://www.openoffice.org/about_us/introduction.html Also read the sections below of getting involved the OpenOffice.org project.
+
+Contents
+
+  System Requirements
+      Linux Intel
+      Windows
+      Solaris Sparc
+      Solaris Intel
+      Linux PowerPC
+
+  Common Notes
+      Network Installation: Error when calling the OpenOffice.org QuickStarter (Windows)
+      Changing the User Interface Font
+      Deinstalling a Network Installation Under Common Desktop Environment (CDE) (Solaris only)
+      Mozilla Address Book Driver (Solaris only)
+      File System ReiserFS: OpenOffice.org Will Not Start for User IDs Larger Than 65536
+      File Locking
+      Using Info-ZIP
+      Used/Modified Source Code
+
+  Getting Involved
+      Registration
+      User Survey
+      Report Bugs & Issues
+      Subscribe
+      Join one or more Projects
+      User Support
+      Way to start
+
+
+System Requirements 
+
+
+Linux Intel 
+
+
+* Linux Kernel version 2.2.13 or higher
+* glibc2 version 2.1.3 or higher
+* - Pentium compatible PC
+* 64 MB RAM
+* 250 MB available hard disk space
+* X Server with 800x600 or higher resolution, with at least 256 colors
+* Window Manager
+
+
+Windows
+
+
+* Microsoft Windows 95, 98, ME, NT (Service Pack 6 or higher), 2000 or XP (Please note: Windows 95 requires a DCOM95 update. For further information, visit http://www.microsoft.com/com/dcom/dcom95/dcom1_3.asp)
+* Pentium compatible PC
+* 64 MB RAM
+* 250 MB available hard disk space
+* 800x600 DPI resolution or higher, at least 256 colors
+
+Note: Please be aware that administrator rights are needed for the installation process.
+Make sure you have enough free memory in your temporary directory.
+
+Solaris Sparc 
+
+
+* Solaris 7 operating system (SPARC platform) or higher (Solaris 8 recommended)
+* 128 MB RAM
+* 250 MB available hard disk space
+* X Server with 800x600 or higher resolution, with at least 256 colors
+* Window Manager
+
+Important information about the installation of OpenOffice.org on the Sun Solaris platform:
+Before installing OpenOffice.org, one or more operating system patches from Sun Microsystems must be installed. You can download them at http://sunsolve.sun.com
+Operating system patches required:
+
+* for Solaris 7: 106327-08, 106300-09 (only 64 bit)
+* for Solaris 8: 108434-01, 108773-12, 108435-01 (only 64 bit)
+
+The versions mentioned above are the minimum requirements, newer (higher) version numbers are also allowed.
+
+Solaris Intel 
+
+
+* Solaris 7 operating system (Intel platform) or higher (Solaris 8 recommended)
+* 64 MB RAM
+* 250 MB available hard disk space
+* X Server with 800x600 or higher resolution, with at least 256 colors
+* Window Manager
+
+Important information about the installation of OpenOffice.org on the Sun Solaris platform:
+Before installing OpenOffice.org, one or more operating system patches from Sun Microsystems must be installed. You can download them at http://sunsolve.sun.com
+Operating system patches required:
+
+* for Solaris 7: 106328-08
+* for Solaris 8: 108436-01, 108774-12
+
+The versions mentioned above are the minimum requirements, newer (higher) version numbers are also allowed.
+
+Linux PowerPC
+
+
+* Linux Kernel version 2.2.13 or higher
+* glibc2 version 2.2 or higher
+* Macintosh PowerPC, IBM RS/6000, Motorola PreP or other Linux compatible PowerPC based hardware
+* 96 MB RAM
+* 250 MB available hard disk space
+* X Server with 800x600 or higher resolution, with at least 256 colors
+* Window Manager
+
+
+Common Notes
+
+You can install OpenOffice.org 1.0 along side of an older version of OpenOffice.org. If you later choose to deinstall a previous version of OpenOffice.org, you must call the setup program of the newer version and run the Repair option. This makes sure that the new version is correctly registered in your system.
+Make sure you have enough free memory in your temporary directory.
+
+Network Installation: Error When Calling the OpenOffice.org Quickstarter (Windows)
+
+If, when starting the system, problems should occur in calling the OpenOffice.org Quickstarter (e.g. invalid link), this is probably due to the fact that the network drive on which the network installation is installed is not or not yet available.
+In most cases, this happens when the network drives are logged in via a login script, thereby establishing the connection for the network drives parallel to running the programs of the autostart group from which the Quickstarter is also started.
+To avoid this problem, the network drive should be connected via the system's services. If this is not possible, the link used to call the Quickstarter can be removed from the autostart group of the system, or the Quickstarter can already be disabled when installing the workstation installation. If the system administrator already disabled the Quickstarter during installation of the network installation, then the Quickstarter cannot be selected by the user in a later workstation installation.
+
+Changing the User Interface Font
+
+In OpenOffice.org you can change the font used for screen display and printing by replacing it with a different font installed on your system. This can be done using the font replacement function. Choose Tools - Options - OpenOffice.org - Font Replacement to access this function.
+To change the font of the OpenOffice.org user interface, you have to replace the default font "Andale Sans UI" with another font and mark the "always" setting for this replacement.
+Refer to the OpenOffice.org Help for a detailed explanation of the dialog.
+
+Deinstalling a Network Installation Under Common Desktop Environment (CDE) (Solaris)
+
+The shortcuts set in the CDE in a network installation are not automatically removed during deinstallation. Before deinstallation, enter as Administrator (root) the following command line to remove the shortcuts from the CDE: /usr/dt/bin/dtappintegrate -u -s [path to OpenOffice.org].
+Example: /usr/dt/bin/dtappintegrate -u -s /usr/local/openoffice.org1.0
+
+Mozilla Address Book Driver (Solaris only)
+
+The Mozilla address book driver requires the SUNWzlib package. This package is not part of the minimum Solaris operating system installation. If you require access to the Mozilla address book, then add this package to your Solaris operating system using the command "pkgadd" from the installation CD.
+
+File System ReiserFS: OpenOffice.org Will Not Start for User IDs Larger Than 65535
+
+In versions lower than 3.6, the file system ReiserFS causes a problem as soon as the user ID is larger than 65535. The problem is that files temporarily saved by OpenOffice.org can no longer be removed by the program itself, but rather only by the system administrator (e.g. /tmp/OSL_PIPE_xxx ). The result is that OpenOffice.org cannot be started. The problem is in the ReiserFS file system and has been fixed in version 3.6 and higher.
+
+File Locking
+
+In the default setting, file locking is turned off in OpenOffice.org. To activate it, you have to set the appropriate environment variables SAL_ENABLE_FILE_LOCKING=1 and export SAL_ENABLE_FILE_LOCKING. These entries are already in disabled form in the soffice script file.
+Warning: The activated file locking feature can cause problems with Solaris 2.5.1 and 2.7 used in conjunction with Linux NFS 2.0. If your system environment has these parameters, we strongly recommend that you avoid using the file locking feature. Otherwise, OpenOffice.org will hang when you try to open a file from a NFS mounted directory from a Linux computer.
+
+Using Info-ZIP
+
+OpenOffice.org uses Info-ZIP to create and unpack the OpenOffice.org installation, as well as for packing and unpacking the OpenOffice.org XML file format. Info-ZIP programs (ZIP, UnZip and other utilities) are available free of charge and can be used in the source code and as an executable program. They can be attained by visiting Anonymous FTP sites such as ftp.uu.net:/pub/archiving/zip/*.
+
+Used / Modified Source Code
+
+Portions Copyright 1998, 1999 James Clark. Portions Copyright 1996, 1998 Netscape Communications Corporation.
+
+
+Getting Involved
+
+The OpenOffice.org Community would very much benefit from your active participation in the development of this important open source project.
+As a User, you are already a valuable part of the suite's development process and we would like to encourage you to take an even more active role with a view to being a long-term contributor to the Community. Please join and checkout the user page at: openoffice.org
+
+Registration
+
+Please take a little time to complete the minimal Product Registration process when you install the software. While registration is optional, we encourage you to register, since the information enables the Community to make an even better software suite and address User needs directly. Through its Privacy Policy, the OpenOffice.org Community takes every precaution to safeguard your personal data. If you missed the registration at installation, you can return and register at any time at www.openoffice.org/welcome/registration-site.html
+
+User Survey
+
+There is also a User Survey located online which we encourage you to fill out. The User Survey results will help OpenOffice.org move more rapidly in setting new standards for the creation of the next-generation office suite. Through its Privacy Policy, the OpenOffice.org Community takes every precaution to safeguard your personal data.
+
+Report Bugs & Issues
+
+The OpenOffice.org Web site hosts IssueZilla, our mechanism for reporting, tracking and solving bugs and issues. We encourage all Users to feel entitled and welcome to report issues that may arise on your particular platform. Energetic reporting of issues is one of the most important contributions that the User Community can make to the ongoing development and improvement of the suite.
+
+Subscribe
+
+Here are a few of the Project mailing lists to which you can subscribe at www.openoffice.org/mail_list.html
+
+* News: announce@openoffice.org *recommended to all users* (light traffic)
+* User support: users@openoffice.org *recommended to new users* (moderate traffic)
+* Main user forum: discuss@openoffice.org *Easy way to lurk on discussions* (heavy)
+* Marketing project: dev@marketing.openoffice.org*beyond development* (getting heavy)
+* General code contributor list: dev@openoffice.org (moderate/heavy)
+* Groupware: groupware@whiteboard.openoffice.org (moderate)
+
+
+Join one or more Projects
+
+You can make major contributions to this important open source project even if you have limited software design or coding experience. Yes, you!
+At http://projects.openoffice.org/index.html you will find projects ranging from Localization, Porting and Groupware to some real core coding projects. If you are not a developer, try the Documentation or the Marketing Project. The OpenOffice.org Marketing Project is applying both guerrilla and traditional commercial techniques to marketing open source software, and we are doing it across language and cultural barriers, so you can help just be spreading the word and telling a friend about this office suite.
+You can help by joining the Marketing Communications & Information Network here: http://marketing.openoffice.org/contacts.html
+where you can provide point communication contact with press, media, government agencies, consultants, schools, Linux Users Groups and developers in your country and local community.
+
+User Support
+
+For help with the OpenOffice.org 1.0 office suite, take a look at the archieves to questions already answered on the 'users@openoffice.org' mailing list at http://www.openoffice.org/mail_list.html. Alternativeely, you can send in your questions to users@openoffice.org. Remember to subscribe to the list to get an email response.
+Also check the FAQ section, found on left hand navigation bar of the OpenOffice.org homepage. Frequently asked questions are posted here.
+
+Way to Start
+
+The best way to start contributing is to subscribe to one or more of the mailing lists, lurk for a while, and gradually use the mail archives to familiarize yourself with many of the topics covered since the OpenOffice.org source code was released back in October 2000. When you're comfortable, all you need to do is make an email self-introduction and jump right in. If you are familiar with Open Source Projects, check out our To-Dos list and see if there is anything you would like to help with at http://www.openoffice.org/dev_docs/todos.html.
+We hope you enjoy working with the new OpenOffice.org 1.0 office suite and join us online.
+The OpenOffice.org community
diff -urN oo_1.0.1_src/bridges/source/cpp_uno/gcc3_linux_s390.old/cpp2uno.cxx oo_1.0.1_src/bridges/source/cpp_uno/gcc3_linux_s390/cpp2uno.cxx
--- oo_1.0.1_src/bridges/source/cpp_uno/gcc3_linux_s390.old/cpp2uno.cxx	1970-01-01 01:00:00.000000000 +0100
+++ oo_1.0.1_src/bridges/source/cpp_uno/gcc3_linux_s390/cpp2uno.cxx	2002-10-15 11:19:26.000000000 +0200
@@ -0,0 +1,759 @@
+/*************************************************************************
+ *
+ *  $RCSfile: cpp2uno.cxx,v $
+ *
+ *  $Revision: 1.1.2.3 $
+ *
+ *  last change: $Author: khendricks $ $Date: 2002/05/19 11:25:52 $
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include <malloc.h>
+#include <hash_map>
+
+#include <rtl/alloc.h>
+#include <osl/mutex.hxx>
+
+#include <uno/data.h>
+#include <typelib/typedescription.hxx>
+
+#include <bridges/cpp_uno/bridge.hxx>
+#include <bridges/cpp_uno/type_misc.hxx>
+
+#include "share.hxx"
+
+
+using namespace ::osl;
+using namespace ::rtl;
+using namespace ::com::sun::star::uno;
+
+namespace CPPU_CURRENT_NAMESPACE
+{
+
+//==================================================================================================
+rtl_StandardModuleCount g_moduleCount = MODULE_COUNT_INIT;
+
+//==================================================================================================
+static typelib_TypeClass cpp2uno_call(
+	cppu_cppInterfaceProxy * pThis,
+	const typelib_TypeDescription * pMemberTypeDescr,
+	typelib_TypeDescriptionReference * pReturnTypeRef, // 0 indicates void return
+	sal_Int32 nParams, typelib_MethodParameter * pParams,
+        void ** gpreg, void ** fpreg, void ** ovrflw,
+	sal_Int64 * pRegisterReturn /* space for register return */ )
+{
+        int ng = 0; //number of gpr registers used 
+        int nf = 0; //number of fpr regsiters used
+        void ** pCppStack; //temporary stack pointer
+       
+        // gpreg:  [ret *], this, [gpr params]
+        // fpreg:  [fpr params]
+        // ovrflw: [gpr or fpr params (properly aligned)]
+
+	// return
+	typelib_TypeDescription * pReturnTypeDescr = 0;
+	if (pReturnTypeRef)
+		TYPELIB_DANGER_GET( &pReturnTypeDescr, pReturnTypeRef );
+	
+	void * pUnoReturn = 0;
+	void * pCppReturn = 0; // complex return ptr: if != 0 && != pUnoReturn, reconversion need
+	
+	if (pReturnTypeDescr)
+	{
+		if (cppu_isSimpleType( pReturnTypeDescr ))
+		{
+			pUnoReturn = pRegisterReturn; // direct way for simple types
+		}
+		else // complex return via ptr (pCppReturn)
+		{
+			pCppReturn = *(void **)gpreg;
+                        gpreg++;
+                        ng++;
+			
+			pUnoReturn = (cppu_relatesToInterface( pReturnTypeDescr )
+						  ? alloca( pReturnTypeDescr->nSize )
+						  : pCppReturn); // direct way
+		}
+	}
+	// pop this
+        gpreg++; 
+        ng++;
+
+	// stack space
+	OSL_ENSURE( sizeof(void *) == sizeof(sal_Int32), "### unexpected size!" );
+	// parameters
+	void ** pUnoArgs = (void **)alloca( 4 * sizeof(void *) * nParams );
+	void ** pCppArgs = pUnoArgs + nParams;
+	// indizes of values this have to be converted (interface conversion cpp<=>uno)
+	sal_Int32 * pTempIndizes = (sal_Int32 *)(pUnoArgs + (2 * nParams));
+	// type descriptions for reconversions
+	typelib_TypeDescription ** ppTempParamTypeDescr = (typelib_TypeDescription **)(pUnoArgs + (3 * nParams));
+	
+	sal_Int32 nTempIndizes   = 0;
+	
+	for ( sal_Int32 nPos = 0; nPos < nParams; ++nPos )
+	{
+		const typelib_MethodParameter & rParam = pParams[nPos];
+		typelib_TypeDescription * pParamTypeDescr = 0;
+		TYPELIB_DANGER_GET( &pParamTypeDescr, rParam.pTypeRef );
+
+		if (!rParam.bOut && cppu_isSimpleType( pParamTypeDescr )) // value
+		{
+
+			switch (pParamTypeDescr->eTypeClass)
+			{
+
+			  case typelib_TypeClass_DOUBLE:
+			   if (nf < 2) {
+			      pCppArgs[nPos] = fpreg;
+			      pUnoArgs[nPos] = fpreg;
+			      nf++;
+			      fpreg += 2;
+			   } else {
+				pCppArgs[nPos] = ovrflw;
+				pUnoArgs[nPos] = ovrflw;
+			        ovrflw += 2;
+			   }
+			   break;
+
+			   case typelib_TypeClass_FLOAT:
+			    // fpreg are all double values so need to
+			    // modify fpreg to be a single word float value
+			    if (nf < 2) {
+//			       float tmp = (float) (*((double *)fpreg));
+//			       (*((float *) fpreg)) = tmp;
+			       pCppArgs[nPos] = fpreg;
+			       pUnoArgs[nPos] = fpreg;
+			       nf++;
+			       fpreg += 2;
+			    } else {
+                              pCppArgs[nPos] = ovrflw;
+			      pUnoArgs[nPos] = ovrflw;
+			      ovrflw += 1;
+                            }
+			    break;
+
+			case typelib_TypeClass_HYPER:
+			case typelib_TypeClass_UNSIGNED_HYPER:
+			 if (ng < 4) {
+			    pCppArgs[nPos] = gpreg;
+			    pUnoArgs[nPos] = gpreg;
+			    ng += 2;
+			    gpreg += 2;
+			 } else {
+			    pCppArgs[nPos] = ovrflw;
+			    pUnoArgs[nPos] = ovrflw;
+			    ovrflw += 2;
+			  }
+			  break;
+
+			case typelib_TypeClass_BYTE:
+			case typelib_TypeClass_BOOLEAN:
+			 if (ng < 5) {
+			      pCppArgs[nPos] = (((char *)gpreg) + 3);
+			      pUnoArgs[nPos] = (((char *)gpreg) + 3);
+			      ng++;
+			      gpreg++;
+			 } else {
+			      pCppArgs[nPos] = (((char *)ovrflw) + 3);
+			      pUnoArgs[nPos] = (((char *)ovrflw) + 3);
+			      ovrflw++;
+			 }
+			 break;
+
+
+		       case typelib_TypeClass_CHAR:
+		       case typelib_TypeClass_SHORT:
+		       case typelib_TypeClass_UNSIGNED_SHORT:
+			if (ng < 5) {
+			      pCppArgs[nPos] = (((char *)gpreg)+ 2);
+			      pUnoArgs[nPos] = (((char *)gpreg)+ 2);
+			      ng++;
+			      gpreg++;
+			} else {
+			      pCppArgs[nPos] = (((char *)ovrflw) + 2);
+			      pUnoArgs[nPos] = (((char *)ovrflw) + 2);
+			      ovrflw++;
+			}
+			break;
+
+
+		      default:
+			if (ng < 5) {
+			      pCppArgs[nPos] = gpreg;
+			      pUnoArgs[nPos] = gpreg;
+			      ng++;
+			      gpreg++;
+			} else {
+			      pCppArgs[nPos] = ovrflw;
+			      pUnoArgs[nPos] = ovrflw;
+			      ovrflw++;
+			}
+                        break;
+
+		        }
+		        // no longer needed
+			TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+		}
+		else // ptr to complex value | ref
+		{
+
+		        if (ng < 5) { 
+		          pCppArgs[nPos] = *(void **)gpreg;
+		          pCppStack = gpreg;
+		          ng++;
+		          gpreg++;
+		        } else {
+		          pCppArgs[nPos] = *(void **)ovrflw;
+		          pCppStack = ovrflw;
+		         ovrflw++;
+		        }
+
+			if (! rParam.bIn) // is pure out
+			{
+				// uno out is unconstructed mem!
+				pUnoArgs[nPos] = alloca( pParamTypeDescr->nSize );
+				pTempIndizes[nTempIndizes] = nPos;
+				// will be released at reconversion
+				ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
+			}
+			// is in/inout
+			else if (cppu_relatesToInterface( pParamTypeDescr ))
+			{
+				uno_copyAndConvertData( pUnoArgs[nPos] = alloca( pParamTypeDescr->nSize ),
+										*(void **)pCppStack, pParamTypeDescr,
+										&pThis->pBridge->aCpp2Uno );
+				pTempIndizes[nTempIndizes] = nPos; // has to be reconverted
+				// will be released at reconversion
+				ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
+			}
+			else // direct way
+			{
+				pUnoArgs[nPos] = *(void **)pCppStack;
+				// no longer needed
+				TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+			}
+		}
+	}
+	
+	// ExceptionHolder
+	uno_Any aUnoExc; // Any will be constructed by callee
+	uno_Any * pUnoExc = &aUnoExc;
+
+	// invoke uno dispatch call
+	(*pThis->pUnoI->pDispatcher)( pThis->pUnoI, pMemberTypeDescr, pUnoReturn, pUnoArgs, &pUnoExc );
+	
+	// in case an exception occured...
+	if (pUnoExc)
+	{
+		// destruct temporary in/inout params
+		for ( ; nTempIndizes--; )
+		{
+			sal_Int32 nIndex = pTempIndizes[nTempIndizes];
+			
+			if (pParams[nIndex].bIn) // is in/inout => was constructed
+				uno_destructData( pUnoArgs[nIndex], ppTempParamTypeDescr[nTempIndizes], 0 );
+			TYPELIB_DANGER_RELEASE( ppTempParamTypeDescr[nTempIndizes] );
+		}
+		if (pReturnTypeDescr)
+			TYPELIB_DANGER_RELEASE( pReturnTypeDescr );
+		
+		raiseException( &aUnoExc, &pThis->pBridge->aUno2Cpp ); // has to destruct the any
+		// is here for dummy
+		return typelib_TypeClass_VOID;
+	}
+	else // else no exception occured...
+	{
+		// temporary params
+		for ( ; nTempIndizes--; )
+		{
+			sal_Int32 nIndex = pTempIndizes[nTempIndizes];
+			typelib_TypeDescription * pParamTypeDescr = ppTempParamTypeDescr[nTempIndizes];
+			
+			if (pParams[nIndex].bOut) // inout/out
+			{
+				// convert and assign
+				uno_destructData( pCppArgs[nIndex], pParamTypeDescr, cpp_release );
+				uno_copyAndConvertData( pCppArgs[nIndex], pUnoArgs[nIndex], pParamTypeDescr,
+										&pThis->pBridge->aUno2Cpp );
+			}
+			// destroy temp uno param
+			uno_destructData( pUnoArgs[nIndex], pParamTypeDescr, 0 );
+			
+			TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+		}
+		// return
+		if (pCppReturn) // has complex return
+		{
+			if (pUnoReturn != pCppReturn) // needs reconversion
+			{
+				uno_copyAndConvertData( pCppReturn, pUnoReturn, pReturnTypeDescr,
+										&pThis->pBridge->aUno2Cpp );
+				// destroy temp uno return
+				uno_destructData( pUnoReturn, pReturnTypeDescr, 0 );
+			}
+			// complex return ptr is set to return reg
+			*(void **)pRegisterReturn = pCppReturn;
+		}
+		if (pReturnTypeDescr)
+		{
+			typelib_TypeClass eRet = (typelib_TypeClass)pReturnTypeDescr->eTypeClass;
+			TYPELIB_DANGER_RELEASE( pReturnTypeDescr );
+			return eRet;
+		}
+		else
+			return typelib_TypeClass_VOID;
+	}
+}
+
+
+//==================================================================================================
+static typelib_TypeClass cpp_mediate(
+	sal_Int32 nVtableCall,
+        void ** gpreg, void ** fpreg, void ** ovrflw,
+	sal_Int64 * pRegisterReturn /* space for register return */ )
+{
+	OSL_ENSURE( sizeof(sal_Int32)==sizeof(void *), "### unexpected!" );
+	
+	// gpreg:  [ret *], this, [other gpr params]
+	// fpreg:  [fpr params]
+	// ovrflw: [gpr or fpr params (properly aligned)]
+
+	// _this_ ptr is patched cppu_XInterfaceProxy object
+	cppu_cppInterfaceProxy * pCppI = NULL;
+	if( nVtableCall & 0x80000000 )
+	{
+		nVtableCall &= 0x7fffffff;
+		pCppI = (cppu_cppInterfaceProxy *)(XInterface *)*(gpreg +1);
+	}
+	else
+    {
+		pCppI = (cppu_cppInterfaceProxy *)(XInterface *)*(gpreg);
+    }
+    
+	typelib_InterfaceTypeDescription * pTypeDescr = pCppI->pTypeDescr;
+	
+	OSL_ENSURE( nVtableCall < pTypeDescr->nMapFunctionIndexToMemberIndex, "### illegal vtable index!" );
+	if (nVtableCall >= pTypeDescr->nMapFunctionIndexToMemberIndex)
+	{
+		throw RuntimeException(
+            OUString::createFromAscii("illegal vtable index!"),
+            (XInterface *)pCppI );
+	}
+	
+	// determine called method
+	OSL_ENSURE( nVtableCall < pTypeDescr->nMapFunctionIndexToMemberIndex, "### illegal vtable index!" );
+	sal_Int32 nMemberPos = pTypeDescr->pMapFunctionIndexToMemberIndex[nVtableCall];
+	OSL_ENSURE( nMemberPos < pTypeDescr->nAllMembers, "### illegal member index!" );
+
+	TypeDescription aMemberDescr( pTypeDescr->ppAllMembers[nMemberPos] );
+    
+	typelib_TypeClass eRet;
+	switch (aMemberDescr.get()->eTypeClass)
+	{
+	case typelib_TypeClass_INTERFACE_ATTRIBUTE:
+	{
+		if (pTypeDescr->pMapMemberIndexToFunctionIndex[nMemberPos] == nVtableCall)
+		{
+			// is GET method
+			eRet = cpp2uno_call(
+				pCppI, aMemberDescr.get(),
+				((typelib_InterfaceAttributeTypeDescription *)aMemberDescr.get())->pAttributeTypeRef,
+				0, 0, // no params
+				gpreg, fpreg, ovrflw, pRegisterReturn );
+		}
+		else
+		{
+			// is SET method
+			typelib_MethodParameter aParam;
+			aParam.pTypeRef =
+				((typelib_InterfaceAttributeTypeDescription *)aMemberDescr.get())->pAttributeTypeRef;
+			aParam.bIn		= sal_True;
+			aParam.bOut		= sal_False;
+			
+			eRet = cpp2uno_call(
+				pCppI, aMemberDescr.get(),
+				0, // indicates void return
+				1, &aParam,
+				gpreg, fpreg, ovrflw, pRegisterReturn );
+		}
+		break;
+	}
+	case typelib_TypeClass_INTERFACE_METHOD:
+	{
+		// is METHOD
+		switch (nVtableCall)
+		{
+		case 1: // acquire()
+			pCppI->acquireProxy(); // non virtual call!
+			eRet = typelib_TypeClass_VOID;
+			break;
+		case 2: // release()
+			pCppI->releaseProxy(); // non virtual call!
+			eRet = typelib_TypeClass_VOID;
+			break;
+		case 0: // queryInterface() opt
+		{
+			typelib_TypeDescription * pTD = 0;
+			TYPELIB_DANGER_GET( &pTD, reinterpret_cast< Type * >( gpreg[2] )->getTypeLibType() );
+			if (pTD)
+			{
+                XInterface * pInterface = 0;
+                (*pCppI->pBridge->pCppEnv->getRegisteredInterface)(
+                    pCppI->pBridge->pCppEnv,
+                    (void **)&pInterface, pCppI->oid.pData, (typelib_InterfaceTypeDescription *)pTD );
+			
+                if (pInterface)
+                {
+                    ::uno_any_construct(
+                        reinterpret_cast< uno_Any * >( gpreg[0] ),
+                        &pInterface, pTD, cpp_acquire );
+                    pInterface->release();
+                    TYPELIB_DANGER_RELEASE( pTD );
+                    *(void **)pRegisterReturn = gpreg[0];
+                    eRet = typelib_TypeClass_ANY;
+                    break;
+                }
+                TYPELIB_DANGER_RELEASE( pTD );
+            }
+		} // else perform queryInterface()
+		default:
+			eRet = cpp2uno_call(
+				pCppI, aMemberDescr.get(),
+				((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->pReturnTypeRef,
+				((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->nParams,
+				((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->pParams,
+				gpreg, fpreg, ovrflw, pRegisterReturn );
+		}
+		break;
+	}
+	default:
+	{
+		throw RuntimeException(
+            OUString::createFromAscii("no member description found!"),
+            (XInterface *)pCppI );
+		// is here for dummy
+		eRet = typelib_TypeClass_VOID;
+	}
+	}
+
+	return eRet;
+}
+
+//==================================================================================================
+/**
+ * is called on incoming vtable calls
+ * (called by asm snippets)
+ */
+static void cpp_vtable_call( int nTableEntry, void** gpregptr, void** fpregptr, void** ovrflw)
+{
+        sal_Int32     gpreg[8];
+        double        fpreg[8];
+
+        memcpy( gpreg, gpregptr, 32);
+        memcpy( fpreg, fpregptr, 64);
+
+	volatile long nRegReturn[2];
+
+        sal_Bool bComplex = nTableEntry & 0x80000000 ? sal_True : sal_False;
+
+	typelib_TypeClass aType = 
+             cpp_mediate( nTableEntry, (void**)gpreg, (void**)fpreg, ovrflw, (sal_Int64*)nRegReturn );
+    
+	switch( aType )
+	{
+
+                // move return value into register space
+                // (will be loaded by machine code snippet)
+
+                case typelib_TypeClass_BOOLEAN:
+		  {
+                  unsigned long tmp = (unsigned long)(*(unsigned char *)nRegReturn);
+                  __asm__ volatile ( "l 2,%0\n\t" : :
+			   "m"(tmp) : "2" );
+                  break;
+		  }
+                case typelib_TypeClass_BYTE:
+		  {
+                  long tmp = (long)(*(signed char *)nRegReturn);
+                  __asm__ volatile ( "l 2,%0\n\t" : :
+			   "m"(tmp) : "2" );
+                  break;
+		  }
+                case typelib_TypeClass_CHAR:
+                case typelib_TypeClass_UNSIGNED_SHORT:
+		  {
+                  unsigned long tmp = (unsigned long)(*(unsigned short *)nRegReturn);
+                  __asm__ volatile ( "l 2,%0\n\t" : :
+			   "m"(tmp) : "2" );
+                  break;
+		  }
+                case typelib_TypeClass_SHORT:
+		  {
+                  long tmp = (long)(*(short *)nRegReturn);
+                  __asm__ volatile ( "l 2,%0\n\t" : :
+			   "m"(tmp) : "2" );
+                  break;
+		  }
+		case typelib_TypeClass_FLOAT:
+                  __asm__ volatile ( "le 0,%0\n\t" : :
+                           "m" (*((float*)nRegReturn)) : "16" );
+		  break;
+
+		case typelib_TypeClass_DOUBLE:
+		  __asm__ volatile ( "ld 0,%0\n\t" : :
+                           "m" (*((double*)nRegReturn)) : "16" );
+		  break;
+
+		case typelib_TypeClass_HYPER:
+		case typelib_TypeClass_UNSIGNED_HYPER:
+		  __asm__ volatile ( "lm 2,3,%0\n\t" : :
+                           "m"(nRegReturn[0]) : "2", "3" );
+		  break;
+
+		default:
+		  __asm__ volatile ( "l 2,%0\n\t" : :
+                           "m"(nRegReturn[0]) : "2" );
+		  break;
+	}
+}
+
+
+//==================================================================================================
+class MediateClassData
+{
+    typedef ::std::hash_map< OUString, void *, OUStringHash > t_classdata_map;
+	t_classdata_map m_map;
+	Mutex m_mutex;
+    
+public:
+	void const * get_vtable( typelib_InterfaceTypeDescription * pTD ) SAL_THROW( () );
+    
+	inline MediateClassData() SAL_THROW( () )
+        {}
+	~MediateClassData() SAL_THROW( () );
+};
+//__________________________________________________________________________________________________
+MediateClassData::~MediateClassData() SAL_THROW( () )
+{
+	OSL_TRACE( "> calling ~MediateClassData(): freeing mediate vtables." );
+	
+	for ( t_classdata_map::const_iterator iPos( m_map.begin() ); iPos != m_map.end(); ++iPos )
+	{
+		::rtl_freeMemory( iPos->second );
+	}
+}
+//--------------------------------------------------------------------------------------------------
+static inline void codeSnippet( long * code, sal_uInt32 vtable_pos, bool simple_ret_type ) SAL_THROW( () )
+{
+    if (! simple_ret_type)
+        vtable_pos |= 0x80000000;
+    OSL_ASSERT( sizeof (long) == 4 );
+
+     /* generate this code */
+     // lr      %r0,%r13
+     // bras    %r13,0x6
+     // .long   cpp_vtable_call 
+     // .long   vtable_pos
+     // stm     %r2,%r6,8(%r15)
+     // std     %f0,64(%r15)
+     // std     %f2,72(%r15)
+
+     // l       %r2,4(%r13)
+     // la      %r3,8(%r15)
+     // la      %r4,64(%r15)
+     // la      %r5,96(%r15)   
+     // l       %r1,0(%r13)
+     // lr      %r13,%r0
+     // br      %r1
+
+
+      * ((short*)code)++ = 0x180d;
+      * code++ = 0xa7d50006;
+      * code++ = cpp_vtable_call;
+      * code++ = vtable_pos;
+      * code++ = 0x9026f008;
+      * code++ = 0x6000f040;
+      * code++ = 0x6020f048;
+      * code++ = 0x5820d004;
+      * code++ = 0x4130f008;
+      * code++ = 0x4140f040;
+      * code++ = 0x4150f060;
+      * code++ = 0x5810d000;
+      * ((short*)code)++ = 0x18d0;
+      * ((short*)code)++ = 0x07f1;
+
+}
+//__________________________________________________________________________________________________
+void const * MediateClassData::get_vtable( typelib_InterfaceTypeDescription * pTD ) SAL_THROW( () )
+{
+    void * buffer;
+    const int nSnippetSize = 50;
+
+    // avoiding locked counts
+    OUString const & unoName = *(OUString const *)&((typelib_TypeDescription *)pTD)->pTypeName;
+    {
+	MutexGuard aGuard( m_mutex );
+	t_classdata_map::const_iterator iFind( m_map.find( unoName ) );
+	if (iFind == m_map.end())
+    {
+        // create new vtable
+        sal_Int32 nSlots = pTD->nMapFunctionIndexToMemberIndex;
+        buffer = ::rtl_allocateMemory( ((2+ nSlots) * sizeof (void *)) + (nSlots *nSnippetSize) );
+        
+        ::std::pair< t_classdata_map::iterator, bool > insertion(
+            m_map.insert( t_classdata_map::value_type( unoName, buffer ) ) );
+        OSL_ENSURE( insertion.second, "### inserting new vtable buffer failed?!" );
+        
+        void ** slots = (void **)buffer;
+        *slots++ = 0;
+        *slots++ = 0; // rtti
+        char * code = (char *)(slots + nSlots);
+        
+        sal_uInt32 vtable_pos = 0;
+        sal_Int32 nAllMembers = pTD->nAllMembers;
+        typelib_TypeDescriptionReference ** ppAllMembers = pTD->ppAllMembers;
+        for ( sal_Int32 nPos = 0; nPos < nAllMembers; ++nPos )
+        {
+            typelib_TypeDescription * pTD = 0;
+            TYPELIB_DANGER_GET( &pTD, ppAllMembers[ nPos ] );
+            OSL_ASSERT( pTD );
+            if (typelib_TypeClass_INTERFACE_ATTRIBUTE == pTD->eTypeClass)
+            {
+                bool simple_ret = cppu_isSimpleType(
+                    ((typelib_InterfaceAttributeTypeDescription *)pTD)->pAttributeTypeRef->eTypeClass );
+                // get method
+                *slots = code;
+                codeSnippet( (long *)code, vtable_pos++, simple_ret );
+                code += nSnippetSize;
+                slots++;
+                if (! ((typelib_InterfaceAttributeTypeDescription *)pTD)->bReadOnly)
+                {
+                    // set method
+                    *slots = code;
+                    codeSnippet( (long *)code, vtable_pos++, true );
+                    code += nSnippetSize;
+                    slots++;
+                }
+            }
+            else
+            {
+                bool simple_ret = cppu_isSimpleType(
+                    ((typelib_InterfaceMethodTypeDescription *)pTD)->pReturnTypeRef->eTypeClass );
+                *slots = code;
+                codeSnippet( (long *)code, vtable_pos++, simple_ret );
+                code += nSnippetSize;
+                slots++;
+            }
+            TYPELIB_DANGER_RELEASE( pTD );
+        }
+        OSL_ASSERT( vtable_pos == nSlots );
+    }
+    else
+    {
+        buffer = iFind->second;
+    }
+    }
+    
+    return ((void **)buffer +2);
+}
+
+//==================================================================================================
+void SAL_CALL cppu_cppInterfaceProxy_patchVtable(
+	XInterface * pCppI, typelib_InterfaceTypeDescription * pTypeDescr ) throw ()
+{
+	static MediateClassData * s_pMediateClassData = 0;
+	if (! s_pMediateClassData)
+	{
+		MutexGuard aGuard( Mutex::getGlobalMutex() );
+		if (! s_pMediateClassData)
+		{
+#ifdef LEAK_STATIC_DATA
+			s_pMediateClassData = new MediateClassData();
+#else
+			static MediateClassData s_aMediateClassData;
+			s_pMediateClassData = &s_aMediateClassData;
+#endif
+		}
+	}
+	*(void const **)pCppI = s_pMediateClassData->get_vtable( pTypeDescr );
+}
+
+}
+
+extern "C"
+{
+//##################################################################################################
+sal_Bool SAL_CALL component_canUnload( TimeValue * pTime )
+	SAL_THROW_EXTERN_C()
+{
+	return CPPU_CURRENT_NAMESPACE::g_moduleCount.canUnload(
+        &CPPU_CURRENT_NAMESPACE::g_moduleCount, pTime );
+}
+//##################################################################################################
+void SAL_CALL uno_initEnvironment( uno_Environment * pCppEnv )
+	SAL_THROW_EXTERN_C()
+{
+	CPPU_CURRENT_NAMESPACE::cppu_cppenv_initEnvironment(
+        pCppEnv );
+}
+//##################################################################################################
+void SAL_CALL uno_ext_getMapping(
+	uno_Mapping ** ppMapping, uno_Environment * pFrom, uno_Environment * pTo )
+	SAL_THROW_EXTERN_C()
+{
+	CPPU_CURRENT_NAMESPACE::cppu_ext_getMapping(
+        ppMapping, pFrom, pTo );
+}
+}
diff -urN oo_1.0.1_src/bridges/source/cpp_uno/gcc3_linux_s390.old/except.cxx oo_1.0.1_src/bridges/source/cpp_uno/gcc3_linux_s390/except.cxx
--- oo_1.0.1_src/bridges/source/cpp_uno/gcc3_linux_s390.old/except.cxx	1970-01-01 01:00:00.000000000 +0100
+++ oo_1.0.1_src/bridges/source/cpp_uno/gcc3_linux_s390/except.cxx	2002-09-29 19:38:18.000000000 +0200
@@ -0,0 +1,317 @@
+/*************************************************************************
+ *
+ *  $RCSfile: except.cxx,v $
+ *
+ *  $Revision: 1.6 $
+ *
+ *  last change: $Author: dbo $ $Date: 2001/11/08 12:35:28 $
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include <stdio.h>
+#include <dlfcn.h>
+#include <cxxabi.h>
+#include <hash_map>
+
+#include <rtl/strbuf.hxx>
+#include <rtl/ustrbuf.hxx>
+#include <osl/diagnose.h>
+#include <osl/mutex.hxx>
+
+#include <bridges/cpp_uno/bridge.hxx>
+#include <typelib/typedescription.hxx>
+#include <uno/any2.h>
+
+#include "share.hxx"
+
+
+using namespace ::std;
+using namespace ::osl;
+using namespace ::rtl;
+using namespace ::com::sun::star::uno;
+using namespace ::__cxxabiv1;
+
+
+namespace CPPU_CURRENT_NAMESPACE
+{
+    
+void dummy_can_throw_anything( char const * )
+{
+}
+
+//==================================================================================================
+static OUString toUNOname( char const * p ) SAL_THROW( () )
+{
+#ifdef DEBUG
+    char const * start = p;
+#endif
+    
+    // example: N3com3sun4star4lang24IllegalArgumentExceptionE
+    
+	OUStringBuffer buf( 64 );
+    OSL_ASSERT( 'N' == *p );
+    ++p; // skip N
+    
+    while ('E' != *p)
+    {
+        // read chars count
+        long n = (*p++ - '0');
+        while ('0' <= *p && '9' >= *p)
+        {
+            n *= 10;
+            n += (*p++ - '0');
+        }
+        buf.appendAscii( p, n );
+        p += n;
+        if ('E' != *p)
+            buf.append( (sal_Unicode)'.' );
+    }
+    
+#ifdef DEBUG
+    OUString ret( buf.makeStringAndClear() );
+    OString c_ret( OUStringToOString( ret, RTL_TEXTENCODING_ASCII_US ) );
+    fprintf( stderr, "> toUNOname(): %s => %s\n", start, c_ret.getStr() );
+    return ret;
+#else
+    return buf.makeStringAndClear();
+#endif
+}
+
+//==================================================================================================
+class RTTI
+{
+    typedef hash_map< OUString, type_info *, OUStringHash > t_rtti_map;
+    
+    Mutex m_mutex;
+	t_rtti_map m_rttis;
+    t_rtti_map m_generatedRttis;
+
+    void * m_hApp;
+    
+public:
+    RTTI() SAL_THROW( () );
+    ~RTTI() SAL_THROW( () );
+    
+    type_info * getRTTI( typelib_CompoundTypeDescription * ) SAL_THROW( () );
+};
+//__________________________________________________________________________________________________
+RTTI::RTTI() SAL_THROW( () )
+    : m_hApp( dlopen( 0, RTLD_LAZY ) )
+{
+}
+//__________________________________________________________________________________________________
+RTTI::~RTTI() SAL_THROW( () )
+{
+    dlclose( m_hApp );
+}
+
+//__________________________________________________________________________________________________
+type_info * RTTI::getRTTI( typelib_CompoundTypeDescription *pTypeDescr ) SAL_THROW( () )
+{
+    type_info * rtti;
+    
+    OUString const & unoName = *(OUString const *)&pTypeDescr->aBase.pTypeName;
+    
+    MutexGuard guard( m_mutex );
+    t_rtti_map::const_iterator iFind( m_rttis.find( unoName ) );
+    if (iFind == m_rttis.end())
+    {
+        // RTTI symbol
+        OStringBuffer buf( 64 );
+        buf.append( RTL_CONSTASCII_STRINGPARAM("_ZTIN") );
+        sal_Int32 index = 0;
+        do
+        {
+            OUString token( unoName.getToken( 0, '.', index ) );
+            buf.append( token.getLength() );
+            OString c_token( OUStringToOString( token, RTL_TEXTENCODING_ASCII_US ) );
+            buf.append( c_token );
+        }
+        while (index >= 0);
+        buf.append( 'E' );
+        
+        OString symName( buf.makeStringAndClear() );
+        rtti = (type_info *)dlsym( m_hApp, symName.getStr() );
+
+        if (rtti)
+        {
+            pair< t_rtti_map::iterator, bool > insertion(
+                m_rttis.insert( t_rtti_map::value_type( unoName, rtti ) ) );
+            OSL_ENSURE( insertion.second, "### inserting new rtti failed?!" );
+        }
+        else
+        {
+            // try to lookup the symbol in the generated rtti map
+            t_rtti_map::const_iterator iFind( m_generatedRttis.find( unoName ) );
+            if (iFind == m_generatedRttis.end())
+            {
+                // we must generate it !
+                // symbol and rtti-name is nearly identical,
+                // the symbol is prefixed with _ZTI
+                char const * rttiName = symName.getStr() +4;
+#ifdef DEBUG
+                fprintf( stderr,"generated rtti for %s\n", rttiName );
+#endif
+                if (pTypeDescr->pBaseTypeDescription)
+                {
+                    // ensure availability of base
+                    type_info * base_rtti = getRTTI(
+                        (typelib_CompoundTypeDescription *)pTypeDescr->pBaseTypeDescription );
+                    rtti = new __si_class_type_info(
+                        strdup( rttiName ), (__class_type_info *)base_rtti );
+                }
+                else
+                {
+                    // this class has no base class
+                    rtti = new __class_type_info( strdup( rttiName ) );
+                }
+                
+                pair< t_rtti_map::iterator, bool > insertion(
+                    m_generatedRttis.insert( t_rtti_map::value_type( unoName, rtti ) ) );
+                OSL_ENSURE( insertion.second, "### inserting new generated rtti failed?!" );
+            }
+            else // taking already generated rtti
+            {
+                rtti = iFind->second;
+            }
+        }
+    }
+    else
+    {
+        rtti = iFind->second;
+    }
+    
+    return rtti;
+}
+
+//--------------------------------------------------------------------------------------------------
+static void deleteException( void * pExc )
+{
+    __cxa_exception const * header = ((__cxa_exception const *)pExc - 1);
+    typelib_TypeDescription * pTD = 0;
+    OUString unoName( toUNOname( header->exceptionType->name() ) );
+    ::typelib_typedescription_getByName( &pTD, unoName.pData );
+    OSL_ENSURE( pTD, "### unknown exception type! leaving out destruction => leaking!!!" );
+    if (pTD)
+    {
+		::uno_destructData( pExc, pTD, cpp_release );
+		::typelib_typedescription_release( pTD );
+	}
+}
+
+//==================================================================================================
+void raiseException( uno_Any * pUnoExc, uno_Mapping * pUno2Cpp )
+{
+    void * pCppExc;
+    type_info * rtti;
+
+    {
+    // construct cpp exception object
+	typelib_TypeDescription * pTypeDescr = 0;
+	TYPELIB_DANGER_GET( &pTypeDescr, pUnoExc->pType );
+    OSL_ASSERT( pTypeDescr );
+    if (! pTypeDescr)
+        terminate();
+    
+	pCppExc = __cxa_allocate_exception( pTypeDescr->nSize );
+	::uno_copyAndConvertData( pCppExc, pUnoExc->pData, pTypeDescr, pUno2Cpp );
+	
+	// destruct uno exception
+	::uno_any_destruct( pUnoExc, 0 );
+    // avoiding locked counts
+    static RTTI * s_rtti = 0;
+    if (! s_rtti)
+    {
+        MutexGuard guard( Mutex::getGlobalMutex() );
+        if (! s_rtti)
+        {
+#ifdef LEAK_STATIC_DATA
+            s_rtti = new RTTI();
+#else
+            static RTTI rtti_data;
+            s_rtti = &rtti_data;
+#endif
+        }
+    }
+	rtti = (type_info *)s_rtti->getRTTI( (typelib_CompoundTypeDescription *) pTypeDescr );
+    TYPELIB_DANGER_RELEASE( pTypeDescr );
+    OSL_ENSURE( rtti, "### no rtti for throwing exception!" );
+    if (! rtti)
+        terminate();
+    }
+    
+	__cxa_throw( pCppExc, rtti, deleteException );
+}
+
+//==================================================================================================
+void fillUnoException( __cxa_exception * header, uno_Any * pExc, uno_Mapping * pCpp2Uno )
+{
+    OSL_ENSURE( header, "### no exception header!!!" );
+    if (! header)
+        terminate();
+    
+	typelib_TypeDescription * pExcTypeDescr = 0;
+    OUString unoName( toUNOname( header->exceptionType->name() ) );
+	::typelib_typedescription_getByName( &pExcTypeDescr, unoName.pData );
+    OSL_ENSURE( pExcTypeDescr, "### can not get type description for exception!!!" );
+    if (! pExcTypeDescr)
+        terminate();
+    
+    // construct uno exception any
+    ::uno_any_constructAndConvert( pExc, header->adjustedPtr, pExcTypeDescr, pCpp2Uno );
+    ::typelib_typedescription_release( pExcTypeDescr );
+}
+
+}
+
diff -urN oo_1.0.1_src/bridges/source/cpp_uno/gcc3_linux_s390.old/makefile.mk oo_1.0.1_src/bridges/source/cpp_uno/gcc3_linux_s390/makefile.mk
--- oo_1.0.1_src/bridges/source/cpp_uno/gcc3_linux_s390.old/makefile.mk	1970-01-01 01:00:00.000000000 +0100
+++ oo_1.0.1_src/bridges/source/cpp_uno/gcc3_linux_s390/makefile.mk	2002-09-29 19:38:18.000000000 +0200
@@ -0,0 +1,112 @@
+#*************************************************************************
+#
+#   $RCSfile: makefile.mk,v $
+#
+#   $Revision: 1.2 $
+#
+#   last change: $Author: dbo $ $Date: 2001/10/26 14:23:30 $
+#
+#   The Contents of this file are made available subject to the terms of
+#   either of the following licenses
+#
+#          - GNU Lesser General Public License Version 2.1
+#          - Sun Industry Standards Source License Version 1.1
+#
+#   Sun Microsystems Inc., October, 2000
+#
+#   GNU Lesser General Public License Version 2.1
+#   =============================================
+#   Copyright 2000 by Sun Microsystems, Inc.
+#   901 San Antonio Road, Palo Alto, CA 94303, USA
+#
+#   This library is free software; you can redistribute it and/or
+#   modify it under the terms of the GNU Lesser General Public
+#   License version 2.1, as published by the Free Software Foundation.
+#
+#   This library is distributed in the hope that it will be useful,
+#   but WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#   Lesser General Public License for more details.
+#
+#   You should have received a copy of the GNU Lesser General Public
+#   License along with this library; if not, write to the Free Software
+#   Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+#   MA  02111-1307  USA
+#
+#
+#   Sun Industry Standards Source License Version 1.1
+#   =================================================
+#   The contents of this file are subject to the Sun Industry Standards
+#   Source License Version 1.1 (the "License"); You may not use this file
+#   except in compliance with the License. You may obtain a copy of the
+#   License at http://www.openoffice.org/license.html.
+#
+#   Software provided under this License is provided on an "AS IS" basis,
+#   WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+#   WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+#   MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+#   See the License for the specific provisions governing your rights and
+#   obligations concerning the Software.
+#
+#   The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+#
+#   Copyright: 2000 by Sun Microsystems, Inc.
+#
+#   All Rights Reserved.
+#
+#   Contributor(s): _______________________________________
+#
+#
+#
+#*************************************************************************
+
+PRJ=..$/..$/..
+
+PRJNAME=bridges
+TARGET=gcc3_uno
+LIBTARGET=no
+ENABLE_EXCEPTIONS=TRUE
+NO_BSYMBOLIC=TRUE
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  svpre.mk
+.INCLUDE :  settings.mk
+.INCLUDE :  sv.mk
+
+# --- Files --------------------------------------------------------
+
+.IF "$(COM)$(OS)$(CPU)$(COMNAME)" == "GCCLINUX3gcc3"
+
+.IF "$(cppu_no_leak)" == ""
+CFLAGS += -DLEAK_STATIC_DATA
+.ENDIF
+
+CFLAGSNOOPT=-O0
+
+SLOFILES= \
+	$(SLO)$/except.obj		\
+	$(SLO)$/cpp2uno.obj		\
+	$(SLO)$/uno2cpp.obj
+
+SHL1TARGET= $(TARGET)
+
+SHL1DEF=$(MISC)$/$(SHL1TARGET).def
+SHL1IMPLIB=i$(TARGET)
+SHL1VERSIONMAP=..$/..$/bridge_exports.map
+
+SHL1OBJS= \
+	$(SLO)$/except.obj		\
+	$(SLO)$/cpp2uno.obj		\
+	$(SLO)$/uno2cpp.obj
+
+SHL1STDLIBS= \
+	$(CPPULIB)			\
+	$(SALLIB)
+
+.ENDIF
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE :  target.mk
+
diff -urN oo_1.0.1_src/bridges/source/cpp_uno/gcc3_linux_s390.old/share.hxx oo_1.0.1_src/bridges/source/cpp_uno/gcc3_linux_s390/share.hxx
--- oo_1.0.1_src/bridges/source/cpp_uno/gcc3_linux_s390.old/share.hxx	1970-01-01 01:00:00.000000000 +0100
+++ oo_1.0.1_src/bridges/source/cpp_uno/gcc3_linux_s390/share.hxx	2002-09-29 19:38:18.000000000 +0200
@@ -0,0 +1,120 @@
+/*************************************************************************
+ *
+ *  $RCSfile: share.hxx,v $
+ *
+ *  $Revision: 1.1 $
+ *
+ *  last change: $Author: dbo $ $Date: 2001/10/19 13:32:39 $
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include <typeinfo>
+#include <exception>
+#include <cstddef>
+
+namespace CPPU_CURRENT_NAMESPACE
+{
+
+// ----- following decl from libstdc++-v3/libsupc++/unwind-cxx.h and unwind.h
+
+struct _Unwind_Exception
+{
+    unsigned exception_class __attribute__((__mode__(__DI__)));
+    void * exception_cleanup;
+    unsigned private_1 __attribute__((__mode__(__word__)));
+    unsigned private_2 __attribute__((__mode__(__word__)));
+} __attribute__((__aligned__));
+
+struct __cxa_exception
+{ 
+    ::std::type_info *exceptionType;
+    void (*exceptionDestructor)(void *); 
+    
+    ::std::unexpected_handler unexpectedHandler;
+    ::std::terminate_handler terminateHandler;
+    
+    __cxa_exception *nextException;
+    
+    int handlerCount;
+    
+    int handlerSwitchValue;
+    const unsigned char *actionRecord;
+    const unsigned char *languageSpecificData;
+    void *catchTemp;
+    void *adjustedPtr;
+    
+    _Unwind_Exception unwindHeader;
+};    
+
+extern "C" void *__cxa_allocate_exception(
+    std::size_t thrown_size ) throw();
+extern "C" void __cxa_throw (
+    void *thrown_exception, std::type_info *tinfo, void (*dest) (void *) ) __attribute__((noreturn));
+
+struct __cxa_eh_globals
+{
+    __cxa_exception *caughtExceptions;
+    unsigned int uncaughtExceptions;
+};
+extern "C" __cxa_eh_globals *__cxa_get_globals () throw();
+
+// -----
+
+//==================================================================================================
+void raiseException(
+    uno_Any * pUnoExc, uno_Mapping * pUno2Cpp );
+//==================================================================================================
+void fillUnoException(
+    __cxa_exception * header, uno_Any *, uno_Mapping * pCpp2Uno );
+}
diff -urN oo_1.0.1_src/bridges/source/cpp_uno/gcc3_linux_s390.old/uno2cpp.cxx oo_1.0.1_src/bridges/source/cpp_uno/gcc3_linux_s390/uno2cpp.cxx
--- oo_1.0.1_src/bridges/source/cpp_uno/gcc3_linux_s390.old/uno2cpp.cxx	1970-01-01 01:00:00.000000000 +0100
+++ oo_1.0.1_src/bridges/source/cpp_uno/gcc3_linux_s390/uno2cpp.cxx	2002-10-15 11:17:37.000000000 +0200
@@ -0,0 +1,653 @@
+/*************************************************************************
+ *
+ *  $RCSfile: uno2cpp.cxx,v $
+ *
+ *  $Revision: 1.1.2.3 $
+ *
+ *  last change: $Author: khendricks $ $Date: 2002/05/19 11:25:52 $
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include <malloc.h>
+#include <rtl/alloc.h>
+
+#include <uno/data.h>
+#include <bridges/cpp_uno/bridge.hxx>
+#include <bridges/cpp_uno/type_misc.hxx>
+
+#include "share.hxx"
+
+
+using namespace ::rtl;
+using namespace ::com::sun::star::uno;
+
+namespace CPPU_CURRENT_NAMESPACE
+{
+
+void dummy_can_throw_anything( char const * );
+
+static sal_Int32
+invoke_count_words(char * pPT)
+{
+     sal_Int32 overflow = 0, gpr = 0, fpr = 0;
+     int c;                        // character of parameter type being decoded
+
+     while (*pPT != 'X') {
+       c = *pPT;
+       switch (c) {
+       case 'D':                   /* type is double */
+            if (fpr < 2) fpr++; else overflow+=2;
+            break;
+
+       case 'F':                   /* type is float */
+            if (fpr < 2) fpr++; else overflow++;
+            break;
+
+       case 'H':                /* type is long long */
+            if (gpr < 4) gpr+=2; else gpr=5, overflow+=2;
+            break;
+
+       case 'S':
+       case 'T':
+       case 'B':
+       case 'C':
+            if (gpr < 5) gpr++; else overflow++;
+            break;
+
+       default:
+            if (gpr < 5) gpr++; else overflow++;
+            break;
+       }
+       pPT++;
+     }
+     /* Round up number of overflow words to ensure stack
+       stays aligned to 8 bytes.  */
+     return (overflow + 1) & ~1;
+}
+
+static void
+//invoke_copy_to_stack(sal_Int32 paramCount, sal_Int32 * pStackLongs, char * pPT, sal_Int32* d_ov, sal_Int32 overflow)
+invoke_copy_to_stack(sal_Int32 * pStackLongs, char * pPT, sal_Int32* d_ov, sal_Int32 overflow)
+{
+    sal_Int32 *d_gpr = d_ov + overflow; 
+    sal_Int64 *d_fpr = (sal_Int64 *)(d_gpr + 5);
+    sal_Int32 gpr = 0, fpr = 0;
+    char c;
+
+     while (*pPT != 'X') {
+       c = *pPT;
+       switch (c) {
+       case 'D':                   /* type is double */
+            if (fpr < 2)
+                *((double*)  d_fpr) = *((double *)pStackLongs), d_fpr++, fpr++;
+            else
+                *((double*)  d_ov ) = *((double *)pStackLongs), d_ov+=2;
+
+            pStackLongs += 2;
+            break;
+
+       case 'F':                   /* type is float */
+            if (fpr < 2) {
+                *((sal_Int64*) d_fpr) = 0;
+                *((float*)   d_fpr) = *((float *)pStackLongs), d_fpr++, fpr++;
+              }
+            else {
+                *((sal_Int64*) d_ov) = 0;
+                *((float*)   d_ov ) = *((float *)pStackLongs), d_ov++;
+              }
+
+            pStackLongs += 1;
+            break;
+
+       case 'H':                /* type is long long */
+            if (gpr < 4) {
+                *((sal_Int64*) d_gpr) = *((sal_Int64*) pStackLongs), d_gpr+=2, gpr+=2;
+              }
+            else {
+                *((sal_Int64*) d_ov ) = *((sal_Int64*) pStackLongs), d_ov+=2, gpr=5;
+              }
+            pStackLongs += 2;
+            break;
+
+       case 'S':
+            if (gpr < 5)
+                *((sal_uInt32*)d_gpr) = *((unsigned short*)pStackLongs), d_gpr++, gpr++;
+            else
+                *((sal_uInt32*)d_ov ) = *((unsigned short*)pStackLongs), d_ov++;
+            pStackLongs += 1;
+            break;
+
+       case 'T':
+            if (gpr < 5)
+                *((sal_Int32*)d_gpr) = *((signed short*)pStackLongs), d_gpr++, gpr++;
+            else
+                *((sal_Int32*)d_ov ) = *((signed short*)pStackLongs), d_ov++;
+            pStackLongs += 1;
+            break;
+
+       case 'B':
+            if (gpr < 5)
+                *((sal_uInt32*)d_gpr) = *((unsigned char*)pStackLongs), d_gpr++, gpr++;
+            else
+                *((sal_uInt32*)d_ov ) = *((unsigned char*)pStackLongs), d_ov++;
+            pStackLongs += 1;
+            break;
+
+       case 'C':
+            if (gpr < 5)
+                *((sal_Int32*)d_gpr) = *((signed char*)pStackLongs), d_gpr++, gpr++;
+            else
+                *((sal_Int32*)d_ov ) = *((signed char*)pStackLongs), d_ov++;
+            pStackLongs += 1;
+            break;
+
+       default:
+            if (gpr < 5)
+                *((sal_Int32*)d_gpr) = *pStackLongs, d_gpr++, gpr++;
+            else
+                *((sal_Int32*)d_ov ) = *pStackLongs, d_ov++;
+            pStackLongs += 1;
+            break;
+       }
+       pPT++;
+     }
+}
+
+//==================================================================================================
+static void callVirtualMethod(
+    void * pThis,
+    sal_Int32 nVtableIndex,
+    void * pRegisterReturn,
+    typelib_TypeClass eReturnType,
+    char * pPT,
+    sal_Int32 * pStackLongs,
+    sal_Int32 nStackLongs)
+{
+
+  // parameter list is mixed list of * and values
+  // reference parameters are pointers
+
+  // the basic idea here is to use gpr[5] as a storage area for
+  // the future values of registers r2 to r6 needed for the call, 
+  // and similarly fpr[2] as a storage area for the future values
+  // of floating point registers f0 to f2
+
+     sal_Int32 *vtable = *(sal_Int32 **)pThis;
+//    sal_Int32 method = vtable[nVtableIndex + 2];
+     sal_Int32 method = vtable[nVtableIndex];
+     sal_Int32 overflow = invoke_count_words (pPT);
+     sal_Int32 result;
+     volatile double dret;                  // temporary function return values
+     volatile float fret;
+     volatile int iret, iret2;
+
+     char * dummy = alloca(32); // dummy alloca to force r11 usage for exception handling
+
+    __asm__ __volatile__
+     (
+        "lr    7,15\n\t"
+        "ahi   7,-48\n\t"
+
+        "lr    3,%2\n\t"
+        "sll   3,2\n\t"
+        "lcr   3,3\n\t"
+        "l     2,0(15)\n\t"
+        "la    15,0(3,7)\n\t"
+        "st    2,0(15)\n\t"
+
+        "lr    2,%0\n\t"
+        "lr    3,%1\n\t"
+        "la    4,96(15)\n\t"
+        "lr    5,%2\n\t"
+        "basr  14,%3\n\t"
+
+        "ld    0,116(7)\n\t"
+        "ld    2,124(7)\n\t"
+        "lm    2,6,96(7)\n\t"
+        : 
+        : "r" (pStackLongs),
+          "r" (pPT), 
+          "r" (overflow),
+          "a" (invoke_copy_to_stack),
+          "a" (method),
+          "X" (dummy)
+        : "2", "3", "4", "5", "6", "7", "memory"
+    );
+//	"basr  14,%8\n\t"
+
+    (*(void (*)())method)();
+
+    __asm__ __volatile__
+     (
+        "la    15,48(7)\n\t" 
+ 
+        "lr    %2,2\n\t"
+        "lr    %3,3\n\t"
+        "ler   %0,0\n\t"
+        "ldr   %1,0\n\t"
+
+        : "=f" (fret), "=f" (dret), "=r" (iret), "=r" (iret2)
+    );
+
+    switch( eReturnType )
+	{
+		case typelib_TypeClass_HYPER:
+		case typelib_TypeClass_UNSIGNED_HYPER:
+//		        ((long*)pRegisterReturn)[0] = iret;
+			((long*)pRegisterReturn)[1] = iret2;
+		case typelib_TypeClass_LONG:
+		case typelib_TypeClass_UNSIGNED_LONG:
+		case typelib_TypeClass_ENUM:
+			((long*)pRegisterReturn)[0] = iret;
+			break;
+		case typelib_TypeClass_CHAR:
+		case typelib_TypeClass_SHORT:
+		case typelib_TypeClass_UNSIGNED_SHORT:
+		        *(unsigned short*)pRegisterReturn = (unsigned short)iret;
+			break;
+		case typelib_TypeClass_BOOLEAN:
+		case typelib_TypeClass_BYTE:
+		        *(unsigned char*)pRegisterReturn = (unsigned char)iret;
+			break;
+		case typelib_TypeClass_FLOAT:
+		        *(float*)pRegisterReturn = fret;
+			break;
+		case typelib_TypeClass_DOUBLE:
+			*(double*)pRegisterReturn = dret;
+			break;
+	}
+}
+
+
+//================================================================================================== 
+static void cpp_call(
+	cppu_unoInterfaceProxy * pThis,
+	sal_Int32 nVtableCall,
+	typelib_TypeDescriptionReference * pReturnTypeRef,
+	sal_Int32 nParams, typelib_MethodParameter * pParams,
+	void * pUnoReturn, void * pUnoArgs[], uno_Any ** ppUnoExc )
+{
+  	// max space for: [complex ret ptr], values|ptr ...
+  	char * pCppStack		=
+  		(char *)alloca( sizeof(sal_Int32) + ((nParams+2) * sizeof(sal_Int64)) );
+  	char * pCppStackStart	= pCppStack;
+	
+        // need to know parameter types for callVirtualMethod so generate a signature string
+        char * pParamType = (char *) alloca(nParams+2);
+        char * pPT = pParamType;
+
+	// return
+	typelib_TypeDescription * pReturnTypeDescr = 0;
+	TYPELIB_DANGER_GET( &pReturnTypeDescr, pReturnTypeRef );
+	OSL_ENSURE( pReturnTypeDescr, "### expected return type description!" );
+	
+	void * pCppReturn = 0; // if != 0 && != pUnoReturn, needs reconversion
+	
+	if (pReturnTypeDescr)
+	{
+		if (cppu_isSimpleType( pReturnTypeDescr ))
+		{
+			pCppReturn = pUnoReturn; // direct way for simple types
+		}
+		else
+		{
+			// complex return via ptr
+			pCppReturn = *(void **)pCppStack = (cppu_relatesToInterface( pReturnTypeDescr )
+												? alloca( pReturnTypeDescr->nSize )
+												: pUnoReturn); // direct way
+                        *pPT++ = 'I'; //signify that a complex return type on stack
+			pCppStack += sizeof(void *);
+		}
+	}
+	// push this
+	*(void**)pCppStack = pThis->pCppI;
+	pCppStack += sizeof( void* );
+        *pPT++ = 'I';
+
+	// stack space
+	OSL_ENSURE( sizeof(void *) == sizeof(sal_Int32), "### unexpected size!" );
+	// args
+	void ** pCppArgs  = (void **)alloca( 3 * sizeof(void *) * nParams );
+	// indizes of values this have to be converted (interface conversion cpp<=>uno)
+	sal_Int32 * pTempIndizes = (sal_Int32 *)(pCppArgs + nParams);
+	// type descriptions for reconversions
+	typelib_TypeDescription ** ppTempParamTypeDescr = (typelib_TypeDescription **)(pCppArgs + (2 * nParams));
+	
+	sal_Int32 nTempIndizes   = 0;
+	
+	for ( sal_Int32 nPos = 0; nPos < nParams; ++nPos )
+	{
+		const typelib_MethodParameter & rParam = pParams[nPos];
+		typelib_TypeDescription * pParamTypeDescr = 0;
+		TYPELIB_DANGER_GET( &pParamTypeDescr, rParam.pTypeRef );
+		
+		if (!rParam.bOut && cppu_isSimpleType( pParamTypeDescr ))
+		{
+			uno_copyAndConvertData( pCppArgs[nPos] = pCppStack, pUnoArgs[nPos], pParamTypeDescr,
+									&pThis->pBridge->aUno2Cpp );
+
+			switch (pParamTypeDescr->eTypeClass)
+			{
+
+                          // we need to know type of each param so that we know whether to use
+                          // gpr or fpr to pass in parameters:
+                          // Key: I - int, long, pointer, etc means pass in gpr
+                          //      B - byte value passed in gpr
+                          //      S - short value passed in gpr
+                          //      F - float value pass in fpr
+                          //      D - double value pass in fpr
+                          //      H - long long int pass in proper pairs of gpr (3,4) (5,6), etc
+                          //      X - indicates end of parameter description string
+
+		          case typelib_TypeClass_LONG:
+		          case typelib_TypeClass_UNSIGNED_LONG:
+		          case typelib_TypeClass_ENUM:
+			    *pPT++ = 'I';
+			    break;
+ 		          case typelib_TypeClass_SHORT:
+                            *pPT++ = 'T';
+                            break;
+		          case typelib_TypeClass_CHAR:
+		          case typelib_TypeClass_UNSIGNED_SHORT:
+                            *pPT++ = 'S';
+                            break;
+		          case typelib_TypeClass_BOOLEAN:
+                            *pPT++ = 'B';
+                            break;
+		          case typelib_TypeClass_BYTE:
+                            *pPT++ = 'C';
+                            break;
+		          case typelib_TypeClass_FLOAT:
+                            *pPT++ = 'F';
+			    break;
+		        case typelib_TypeClass_DOUBLE:
+			    *pPT++ = 'D';
+			    pCppStack += sizeof(sal_Int32); // extra long
+			    break;
+			case typelib_TypeClass_HYPER:
+			case typelib_TypeClass_UNSIGNED_HYPER:
+			    *pPT++ = 'H';
+			    pCppStack += sizeof(sal_Int32); // extra long
+			}
+
+			// no longer needed
+			TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+		}
+		else // ptr to complex value | ref
+		{
+			if (! rParam.bIn) // is pure out
+			{
+				// cpp out is constructed mem, uno out is not!
+				uno_constructData(
+					*(void **)pCppStack = pCppArgs[nPos] = alloca( pParamTypeDescr->nSize ),
+					pParamTypeDescr );
+				pTempIndizes[nTempIndizes] = nPos; // default constructed for cpp call
+				// will be released at reconversion
+				ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
+			}
+			// is in/inout
+			else if (cppu_relatesToInterface( pParamTypeDescr ))
+			{
+				uno_copyAndConvertData(
+					*(void **)pCppStack = pCppArgs[nPos] = alloca( pParamTypeDescr->nSize ),
+					pUnoArgs[nPos], pParamTypeDescr, &pThis->pBridge->aUno2Cpp );
+				
+				pTempIndizes[nTempIndizes] = nPos; // has to be reconverted
+				// will be released at reconversion
+				ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
+			}
+			else // direct way
+			{
+				*(void **)pCppStack = pCppArgs[nPos] = pUnoArgs[nPos];
+				// no longer needed
+				TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+			}
+                        // KBH: FIXME: is this the right way to pass these
+                        *pPT++='I';
+		}
+		pCppStack += sizeof(sal_Int32); // standard parameter length
+	}
+  
+        // terminate the signature string
+        *pPT++='X';
+        *pPT=0;
+
+	try
+	{
+		OSL_ENSURE( !( (pCppStack - pCppStackStart ) & 3), "UNALIGNED STACK !!! (Please DO panic)" );
+		callVirtualMethod(
+			pThis->pCppI, nVtableCall,
+			pCppReturn, pReturnTypeDescr->eTypeClass, pParamType,
+			(sal_Int32 *)pCppStackStart, (pCppStack - pCppStackStart) / sizeof(sal_Int32) );
+		// NO exception occured...
+		*ppUnoExc = 0;
+		
+		// reconvert temporary params
+		for ( ; nTempIndizes--; )
+		{
+			sal_Int32 nIndex = pTempIndizes[nTempIndizes];
+			typelib_TypeDescription * pParamTypeDescr = ppTempParamTypeDescr[nTempIndizes];
+			
+			if (pParams[nIndex].bIn)
+			{
+				if (pParams[nIndex].bOut) // inout
+				{
+					uno_destructData( pUnoArgs[nIndex], pParamTypeDescr, 0 ); // destroy uno value
+					uno_copyAndConvertData( pUnoArgs[nIndex], pCppArgs[nIndex], pParamTypeDescr,
+											&pThis->pBridge->aCpp2Uno );
+				}
+			}
+			else // pure out
+			{
+				uno_copyAndConvertData( pUnoArgs[nIndex], pCppArgs[nIndex], pParamTypeDescr,
+										&pThis->pBridge->aCpp2Uno );
+			}
+			// destroy temp cpp param => cpp: every param was constructed
+			uno_destructData( pCppArgs[nIndex], pParamTypeDescr, cpp_release );
+			
+			TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+		}
+		// return value
+		if (pCppReturn && pUnoReturn != pCppReturn)
+		{
+			uno_copyAndConvertData( pUnoReturn, pCppReturn, pReturnTypeDescr,
+									&pThis->pBridge->aCpp2Uno );
+			uno_destructData( pCppReturn, pReturnTypeDescr, cpp_release );
+		}
+	}
+ 	catch (...)
+ 	{
+  		// fill uno exception
+		fillUnoException( __cxa_get_globals()->caughtExceptions, *ppUnoExc, &pThis->pBridge->aCpp2Uno );
+        
+		// temporary params
+		for ( ; nTempIndizes--; )
+		{
+			sal_Int32 nIndex = pTempIndizes[nTempIndizes];
+			// destroy temp cpp param => cpp: every param was constructed
+			uno_destructData( pCppArgs[nIndex], ppTempParamTypeDescr[nTempIndizes], cpp_release );
+			TYPELIB_DANGER_RELEASE( ppTempParamTypeDescr[nTempIndizes] );
+		}
+		// return type
+		if (pReturnTypeDescr)
+			TYPELIB_DANGER_RELEASE( pReturnTypeDescr );
+	}
+}
+
+
+//==================================================================================================
+void SAL_CALL cppu_unoInterfaceProxy_dispatch(
+	uno_Interface * pUnoI, const typelib_TypeDescription * pMemberDescr,
+	void * pReturn, void * pArgs[], uno_Any ** ppException ) throw ()
+{
+	// is my surrogate
+	cppu_unoInterfaceProxy * pThis = (cppu_unoInterfaceProxy *)pUnoI;
+	typelib_InterfaceTypeDescription * pTypeDescr = pThis->pTypeDescr;
+	
+	switch (pMemberDescr->eTypeClass)
+	{
+	case typelib_TypeClass_INTERFACE_ATTRIBUTE:
+	{
+		// determine vtable call index
+		sal_Int32 nMemberPos = ((typelib_InterfaceMemberTypeDescription *)pMemberDescr)->nPosition;
+		OSL_ENSURE( nMemberPos < pTypeDescr->nAllMembers, "### member pos out of range!" );
+		
+		sal_Int32 nVtableCall = pTypeDescr->pMapMemberIndexToFunctionIndex[nMemberPos];
+		OSL_ENSURE( nVtableCall < pTypeDescr->nMapFunctionIndexToMemberIndex, "### illegal vtable index!" );
+		
+		if (pReturn)
+		{
+			// dependent dispatch
+			cpp_call(
+				pThis, nVtableCall,
+				((typelib_InterfaceAttributeTypeDescription *)pMemberDescr)->pAttributeTypeRef,
+				0, 0, // no params
+				pReturn, pArgs, ppException );
+		}
+		else
+		{
+			// is SET
+			typelib_MethodParameter aParam;
+			aParam.pTypeRef =
+				((typelib_InterfaceAttributeTypeDescription *)pMemberDescr)->pAttributeTypeRef;
+			aParam.bIn		= sal_True;
+			aParam.bOut		= sal_False;
+
+			typelib_TypeDescriptionReference * pReturnTypeRef = 0;
+			OUString aVoidName( RTL_CONSTASCII_USTRINGPARAM("void") );
+			typelib_typedescriptionreference_new(
+				&pReturnTypeRef, typelib_TypeClass_VOID, aVoidName.pData );
+			
+			// dependent dispatch
+			cpp_call(
+				pThis, nVtableCall +1, // get, then set method
+				pReturnTypeRef,
+				1, &aParam,
+				pReturn, pArgs, ppException );
+			
+			typelib_typedescriptionreference_release( pReturnTypeRef );
+		}
+		
+		break;
+	}
+	case typelib_TypeClass_INTERFACE_METHOD:
+	{
+		// determine vtable call index
+		sal_Int32 nMemberPos = ((typelib_InterfaceMemberTypeDescription *)pMemberDescr)->nPosition;
+		OSL_ENSURE( nMemberPos < pTypeDescr->nAllMembers, "### member pos out of range!" );
+		
+		sal_Int32 nVtableCall = pTypeDescr->pMapMemberIndexToFunctionIndex[nMemberPos];
+		OSL_ENSURE( nVtableCall < pTypeDescr->nMapFunctionIndexToMemberIndex, "### illegal vtable index!" );
+		
+		switch (nVtableCall)
+		{
+			// standard calls
+		case 1: // acquire uno interface
+			(*pUnoI->acquire)( pUnoI );
+			*ppException = 0;
+			break;
+		case 2: // release uno interface
+			(*pUnoI->release)( pUnoI );
+			*ppException = 0;
+			break;
+		case 0: // queryInterface() opt
+		{
+			typelib_TypeDescription * pTD = 0;
+			TYPELIB_DANGER_GET( &pTD, reinterpret_cast< Type * >( pArgs[0] )->getTypeLibType() );
+			if (pTD)
+			{
+                uno_Interface * pInterface = 0;
+                (*pThis->pBridge->pUnoEnv->getRegisteredInterface)(
+                    pThis->pBridge->pUnoEnv,
+                    (void **)&pInterface, pThis->oid.pData, (typelib_InterfaceTypeDescription *)pTD );
+			
+                if (pInterface)
+                {
+                    ::uno_any_construct(
+                        reinterpret_cast< uno_Any * >( pReturn ),
+                        &pInterface, pTD, 0 );
+                    (*pInterface->release)( pInterface );
+                    TYPELIB_DANGER_RELEASE( pTD );
+                    *ppException = 0;
+                    break;
+                }
+                TYPELIB_DANGER_RELEASE( pTD );
+            }
+		} // else perform queryInterface()
+		default:
+			// dependent dispatch
+			cpp_call(
+				pThis, nVtableCall,
+				((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->pReturnTypeRef,
+				((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->nParams,
+				((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->pParams,
+				pReturn, pArgs, ppException );
+		}
+		break;
+	}
+	default:
+	{
+		::com::sun::star::uno::RuntimeException aExc(
+			OUString( RTL_CONSTASCII_USTRINGPARAM("illegal member type description!") ),
+			::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface >() );
+		
+		Type const & rExcType = ::getCppuType( &aExc );
+		// binary identical null reference
+		::uno_type_any_construct( *ppException, &aExc, rExcType.getTypeLibType(), 0 );
+	}
+	}
+}
+
+}
+
--- oo_1.0.1_src/cppu/source/uno/data.cxx.bak	2002-10-15 16:43:37.000000000 +0200
+++ oo_1.0.1_src/cppu/source/uno/data.cxx	2002-10-14 15:18:07.000000000 +0200
@@ -307,7 +307,7 @@
     if (OFFSET_OF(s, m) != n) { fprintf( stderr, "### OFFSET_OF(" #s ", "  #m ") = %d instead of expected %d!!!\n", OFFSET_OF(s, m), n ); abort(); }
 
 #ifdef DEBUG
-#if defined(__GNUC__) && defined(LINUX) && (defined(INTEL) || defined(POWERPC))
+#if defined(__GNUC__) && defined(LINUX) && (defined(INTEL) || defined(POWERPC) || defined(S390))
 #define BINTEST_VERIFYSIZE( s, n ) \
     fprintf( stderr, "> sizeof(" #s ") = %d; __alignof__ (" #s ") = %d\n", sizeof(s), __alignof__ (s) ); \
     if (sizeof(s) != n) { fprintf( stderr, "### sizeof(" #s ") = %d instead of expected %d!!!\n", sizeof(s), n ); abort(); }
--- oo_1.0.1_src/cppu/inc/cppu/macros.hxx.bak	2002-10-15 16:41:44.000000000 +0200
+++ oo_1.0.1_src/cppu/inc/cppu/macros.hxx	2002-10-14 15:16:58.000000000 +0200
@@ -76,7 +76,7 @@
     the struct inherits from a base struct the first member is no double or [unsigned] long long.
     @internal
 */
-#if defined(__GNUC__) && defined(LINUX) && (defined(INTEL) || defined(POWERPC)) && (__GNUC__ == 3)
+#if defined(__GNUC__) && defined(LINUX) && (defined(INTEL) || defined(POWERPC) || defined(S390) ) && (__GNUC__ == 3)
 #define CPPU_GCC3_ALIGN( base_struct ) __attribute__ ((aligned (__alignof__ (base_struct))))
 #else
 #define CPPU_GCC3_ALIGN( base_struct )
--- oo_1.0.1_src/tools/inc/solmath.hxx.bak	2002-10-15 19:19:50.000000000 +0200
+++ oo_1.0.1_src/tools/inc/solmath.hxx	2002-10-15 19:19:12.000000000 +0200
@@ -357,6 +357,10 @@
 /* _FPU_MASK_ZM | _FPU_MASK_OM | _FPU_MASK_UM | _FPU_MASK_IM */
 #define SOMA_FPEXCEPTIONS_ON()	__setfpucw( _FPU_DEFAULT | 0x000000F0 )
 #define SOMA_FPEXCEPTIONS_OFF()	__setfpucw( _FPU_DEFAULT )
+#elif defined(S390)
+#include <fenv.h>
+#define SOMA_FPEXCEPTIONS_ON()	feenableexcept (FE_ALL_EXCEPT)	
+#define SOMA_FPEXCEPTIONS_OFF()	fedisableexcept (FE_ALL_EXCEPT)
 #else
 #define SOMA_FPEXCEPTIONS_ON()	__setfpucw( _FPU_DEFAULT & ~0x001F )
 #define SOMA_FPEXCEPTIONS_OFF()	__setfpucw( _FPU_IEEE )
--- oo_1.0.1_src/config_office/configure.in.bak	2002-11-27 08:04:30.000000000 +0100
+++ oo_1.0.1_src/config_office/configure.in	2002-11-27 08:05:41.000000000 +0100
@@ -829,6 +829,15 @@
    if test "$_os" = "Linux" -a "$_machine_type" = "armv4l"; then
       _jdk_middle=`echo $_jdk | $AWK -F. '{ if ($2 != 2) print "false"; else print "true" }'`
    fi
+   if test "$_os" = "Linux" -a "$_machine_type" = "s390"; then
+      _jdk_middle=`echo $_jdk | $AWK -F. '{ if ($2 != 2) print "false"; else print "true" }'`
+      _jdk_middle3=`echo $_jdk | $AWK -F. '{ if ($2 != 3) print "false"; else print "true" }'`
+
+      if test "$_jdk_middle" = "false" -a "$_jdk_middle3" = "true"; then
+         _jdk_minor="true"
+      fi
+
+   fi
    if test "$_os" = "WINNT"; then
       _jdk_middle=`echo $_jdk | $AWK -F. '{ if ($2 != 2) print "false"; else print "true" }'`
       _jdk_middle3=`echo $_jdk | $AWK -F. '{ if ($2 != 3) print "false"; else print "true" }'`
@@ -863,6 +872,9 @@
          if test "$_machine_type" = "armv4l"; then
             _jdk_minor=`echo $_jdk | $AWK -F. '{ if ($3 != 2) print "false"; else print "true" }'`
          fi 
+         if test "$_machine_type" = "s390"; then
+            _jdk_minor=`echo $_jdk | $AWK -F. '{ if ($3 != 2) print "false"; else print "true" }'`
+         fi 
       fi
       if test "$_os" = "OSF1"; then
          _jdk_minor=`echo $_jdk | $AWK -F- '{print $1}' | $AWK -F. '{ if ($3 != 2) print "false"; else print "true" }'`
