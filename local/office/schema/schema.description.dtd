<!-- Common attributes of schema nodes - these are also found on instances and therefore in the configuration instance namespace
	'name'	    is a required attribute, which must be unique within a package (namespace).
	
	Also common are some (boolean) attributes:
	'writable'	specifies whether values in the node (including any subnodes) can ever be changed or overridden
	           	by a user. If this is set to 'false' in the schema (as opposed to an administration layer) this means,
		that we are dealing with a
	           	The value of 'writable' is inherited by subnodes (even subnodes obtained by <instance> expansion).
	           	The default of 'writable' is 'true' (unless it is specified as 'false' for a whole component).
	           	As 'writable = 'false'' propagates to subnodes, it can only be changed to 'false' in node types
	           	other than <component>.
	'localized'	specifies whether the node has or may have different values for different locales.
		'localized' is inherited by subnodes, similar to XML's 'xml:lang' attribute. 
		This attribute should usually be specified only for <value>s
	'instance-of' 	specifies the template (if any) that defines the type of this node.  Even if there is such a template, 
		providing the attribute is optional.
	'nullable' 	specifies whether it is permissible to have a 'null' (i.e. missing) node.
		The default for 'nullable' is 'true'.
		 If a non-optional (nullable = 'false') <value> has no default value (given here or by an administrator) it must be
		 explicitly specified for each user.
	NOTE: 'nullable' is not in NODE-ATTRIBUTES, as it exists only for value nodes.
-->
<!ENTITY % BOOL 'true | false'>

<!ENTITY % basic-node-attributes ' cfg:writable   (%BOOL; )  #IMPLIED
					cfg:localized  (%BOOL; )  #IMPLIED'>

<!ENTITY % node-attributes ' %basic-node-attributes;
                    cfg:name	NMTOKEN  #REQUIRED'>

<!ENTITY % default-node-attributes ' %basic-node-attributes;
                    cfg:name	CDATA  #REQUIRED'>

<!ENTITY % node-instance-attributes ' %default-node-attributes;
		    cfg:instance-of       CDATA    #IMPLIED' >


<!-- An envelope for a schema component 
	Attributes:
		package: Unique identifier for the containing package
		xml:lang default language that applies to all information items

        Structure of the content part of the schema:
	A <component> node specifies the schema for a particular component of the registry.
	Descendant nodes of a <component> describe subnodes that will actually occur in a configuration
	instance for the given component.
	
	A <templates> node contains reusable types.
	IOW, nodes that appear under it, serve as reusable schema fragments
	Templates that are immediate childs of templates are exported, and can be referenced from other schemas.
	Templates can be
		<value> nodes 		- these act as data type definitions
		<group> and <set> nodes 	- these define a whole subtree structure
		<instance> nodes 	- these provide an alias for an existing (possibly imported) template
	Nodes or subtrees that a template describes will be inserted in the configuration instance,
	whereever a <instance> node in the associated schema refers to that template.
	They can also occur as children of a <set> node that has the template as its element-type.
		
	Template nodes can themselves contain <instance> nodes based on other template nodes. 
	The expansion of <instance> nodes will then proceed recursively.

	Corresponding to the <schema:*> nodes there are <default:*> nodes to hold defaults (including default template instances).
-->
<!ELEMENT schema:component  (schema:documentation? , schema:import* , schema:templates? , schema:schema )>
<!ATTLIST schema:component  cfg:name		NMTOKEN  #REQUIRED
							cfg:package	    NMTOKEN  #REQUIRED
                          xml:lang          NMTOKEN  #IMPLIED
						  schema:category	CDATA	 #IMPLIED
                          xmlns:schema      CDATA    #FIXED "http://openoffice.org/2000/registry/schema/description"
                          xmlns:default     CDATA    #FIXED "http://openoffice.org/2000/registry/schema/default"
                          xmlns:cfg         CDATA    #FIXED "http://openoffice.org/2000/registry/instance"
						  xmlns:xsd         CDATA    #FIXED "http://www.w3.org/1999/XMLSchema"
                          xmlns:xsi         CDATA    #FIXED "http://www.w3.org/1999/XMLSchema-instance">
<!-- this element specifies another schema component that is referenced in this schema 
	The referenced package is given by the "cfg:component" attribute.
	The templates from an imported schema will be needed, when <instance> or <set> entries refer to them.
	The component configuration of an imported package will need to be installed in the configuration database, when 
	<instance> nodes "redirect" to it, or when a configuration <uses> it.
-->
<!ELEMENT schema:import EMPTY>
<!ATTLIST schema:import  cfg:component NMTOKEN  #IMPLIED >
<!-- A <templates> contains complex types in the form of a tree fragment
	The templates of a component will be adressable as by the value of the cfg:component attribute and the name of template.
	When referring to a template from within the current component, cfg:component  can be omitted.
-->
<!ELEMENT schema:templates  (schema:group | schema:set )*>
<!-- A <schema> describes the elements that actually must be present in the configuration for a particular client
	It may contain <uses> elements that specify other (shared) component configurations that also need to be present
	and will be accessed by the client component.
	Often the subtrees of a component configuration will be described as templates. Subtrees corresponding to 
	such templates are specified by <instance> elements. <instance> elements directly contained in a <component>
	should refer only to <group>s and <set>s and not to <value>s.
	
	The <schema> may also directly contain <group> or <set> elements, which will not be available as templates.
-->
<!ELEMENT schema:schema  (schema:documentation? , schema:uses* ,  (schema:group | schema:set | schema:instance )+ )>
<!ATTLIST schema:schema     cfg:writable   (%BOOL; )  "true"
                            			   cfg:localized  (%BOOL; )  "false" >
<!-- A <uses> element specifies a runtime dependency of the component that owns this configuration component on the
       configuration component that is named by the package id. IOW the executable component being installed relies on
       the presence of those configuration items.
       It will access them 
-->
<!ELEMENT schema:uses EMPTY>
<!ATTLIST schema:uses  cfg:component NMTOKEN  #REQUIRED >
<!-- A <group> is a grouping of several related configuration items
	Each item may have a different structure.
	Any combination of <group>, <set> and <value> nodes may be contained in a <group>
	<instance> nodes referring to any node of these types can be used, instead of directly containg an item.
-->
<!ELEMENT schema:group  (schema:documentation? ,  (schema:group | schema:set | schema:instance | schema:value )+ )>
<!ATTLIST schema:group  %node-attributes; >
<!ELEMENT default:group  (default:group | default:set | default:value )+>
<!ATTLIST default:group  %node-instance-attributes; >
<!-- A <set> contains an extensible collection of configuration items
	each of them must be of the same type and have the same structure
	this is enforced by having only a template name to describe those elements
	in attribute "element-type", which must hold the name for a template.
	The template-id defines the package where the template was defined. If the template is defined
	in the current package, the template id does not need to be defined.
	With element-type and template-id it is possible do define the XPath representation element-type/element-type.
	Each element will be as if given by a <instance> referring to this same template.
	Such elements can be given as <default:*> children here. 
	The default elements must match the "element-type" template.
-->
<!ELEMENT schema:set  (schema:documentation? ,  (default:group+ | default:set+ | default:value+ )? )>
<!ATTLIST schema:set  %node-attributes;
                      cfg:element-type CDATA    #REQUIRED
                      cfg:component      NMTOKEN  #IMPLIED >
<!ELEMENT default:set  (default:group+ | default:set+ | default:value+ )?>
<!ATTLIST default:set  %node-instance-attributes;
                       cfg:element-type         CDATA    #REQUIRED
                       cfg:component              NMTOKEN  #IMPLIED >
<!-- A <value> is used to describe a value (leaf) node of the configuration
	The "type" attribute specifies the data type of the value.
	If the "derivedBy" attribute is given with the value "list" the data type is "list of [type]".
	Additional information about the data type can be given in a type-info element.
	The element can specify a default value. 
	
	Default data is always specified by the <default:data> child element. Omitting a default 
	will generate a default of (null, "" or 0; tried in this order).
	Use the "xsi:null" attribute with the value "true" for explicit specifying a NULL default.

	If "cfg:derivedBy" is given as "list", a default may be specified by including a <default:data> child element, containing 
	a <default:data> child with a list of values separated by a whitespace. 
	To use a different separator for the list, "cfg:separator" should be included with the value specifying the separator.

	The <default:data> elements can be used for specifying different default values based on locale. 
	This also requires that "localized" is "true". 
	The "xml:lang" attribute on <default:data> should be given only for localized values.
	Multiple <default:data> children must have different languages specified.
	
	If "cfg:type" is "string" the "xml:space" attribute can be specified as "preserve" on to force preserving whitespace on all children.
	The <default:data> element can also specify this attribute for defaults with preserved whitespace.
	
	If "cfg:type" is "binary" the attribute "encoding" specifies the encoding used; it defaults to "hex" 
	which is currently the only supported encoding. 
	"Hex" binaries are transferred as a string which has two hexadecimal digits for each octet.

	If "cfg:type" is "any", this node must be contained in a template and no default can be given.
	A default:value corresponding to such a template node must hold one of the actual types.

	If the "cfg:constrained" attribute is specified on a default:value, it must be true iif the corresponding schema node
	has a type-info/constraints grand-child.
-->
<!ELEMENT schema:value  (schema:documentation? , schema:type-info? , (default:data+)? )>
<!ATTLIST schema:value  %node-attributes;
                        cfg:type         (boolean | 
                                          short | 
                                          int | 
                                          long | 
                                          double | 
                                          string | 
                                          binary | 
                                          any )  #REQUIRED
                        cfg:derivedBy    (list )  #IMPLIED                        
                        cfg:nullable     (%BOOL; )  "true"
						cfg:encoding	 (hex | base64 )  #IMPLIED
                        cfg:separator   CDATA  #IMPLIED 
						xml:space        (default | preserve )  #IMPLIED >
<!ELEMENT default:value  (default:data+)?>
<!ATTLIST default:value  %node-instance-attributes;
                         cfg:type                  (boolean | 
                                                    short | 
                                                    int | 
                                                    long | 
                                                    double | 
                                                    string | 
                                                    binary )  #REQUIRED
                         cfg:derivedBy             (list )  #IMPLIED
                         cfg:separator            CDATA  #IMPLIED                         
                         cfg:nullable              (%BOOL; )  #IMPLIED
						 cfg:encoding				(hex | base64 )  #IMPLIED
                         cfg:constrained           (%BOOL; )  #IMPLIED 
						 xml:space                 (default | preserve )  #IMPLIED>
<!ELEMENT default:data  (#PCDATA )>
<!ATTLIST default:data  xml:lang		NMTOKEN  #IMPLIED
                        xsi:null      (%BOOL; )  "false" >
<!-- A <instance> refers to a template, and specifies that a named element exemplifying the template should
	be present in this location.
	It may contain a "redirect" attribute, which specifies that the defaults for the instance - or more
	concisely for any contained values - should be retrieved from the named node (which may reside in another
	component). The target of the redirect must be an instance of the same template.
	It may also contain a <default:*> element, which must correspond in structure and attributes to the template.
-->
<!ELEMENT schema:instance  (schema:documentation? ,  (default:group | default:set | default:value )? )>
<!ATTLIST schema:instance  cfg:instance-of CDATA    #REQUIRED
                           cfg:component   NMTOKEN  #IMPLIED
                           %node-attributes;
                           cfg:redirect        CDATA    #IMPLIED >
<!-- Documentation item, can be applied once to (almost) any schema element
	Contains <title> and <description> elements
	If <title> is missing, the naming attribute (often "name") of the element should be used instead.
	
	Both subelements support the xml:lang attribute for specifying localized versions.
	There can be multiple instances of both subelements (in any order).
	Different instances of the same subelement must differ in their language.
	
	Use the xml:space attribute to supply multi-line descriptions.
	Description can support formatted descriptions (e.g. XHTML, OpenOffice.org XML).
 -->
<!ELEMENT schema:documentation  (schema:title | schema:description )*>

<!ELEMENT schema:title  (#PCDATA )>
<!ATTLIST schema:title  xml:lang NMTOKEN  #IMPLIED >
<!ELEMENT schema:description ANY>
<!ATTLIST schema:description  xml:lang  NMTOKEN  #IMPLIED
                              xml:space  (default | preserve )  "default" >
<!-- A type-info gives additional information about the data type of a value
	It may contain
		a (possibly localized) description
		a <constraints> element which describes the constraints on the value
			(more constraint types may be added in the future),
		a <unit> element, which names the unit of the value
			with text describing the unit and its purpose and usage,
		and a <value-names> element, which maps the permissible values to
			textual names (and a description of the value)
-->
<!ELEMENT schema:type-info  (schema:description* , schema:constraints? , schema:unit? , schema:value-names? )*>

<!ELEMENT schema:unit  (schema:description* )>
<!ATTLIST schema:unit  name CDATA  #REQUIRED >
<!ELEMENT schema:value-names  (schema:named-value+ )>
<!ATTLIST schema:value-names  combine  (single | bitmask | sequence )  "single" >
<!ELEMENT schema:named-value  (schema:description* )>
<!ATTLIST schema:named-value  value CDATA  #REQUIRED
                              name  CDATA  #REQUIRED >
<!ELEMENT schema:constraints  (xsd:minInclusive | xsd:minExclusive | xsd:maxInclusive | xsd:maxExclusive | xsd:length | xsd:minLength | xsd:maxLength | xsd:pattern | schema:enumeration )*>
<!ATTLIST schema:constraints  xmlns:xsd CDATA  #FIXED "http://www.w3.org/1999/XMLSchema" >
<!-- XML Schema constraints -->
<!ELEMENT xsd:minInclusive EMPTY>
<!ATTLIST xsd:minInclusive  value CDATA  #REQUIRED >
<!-- must conform to the values type -->
<!ELEMENT xsd:minExclusive EMPTY>
<!ATTLIST xsd:minExclusive  value CDATA  #REQUIRED >
<!-- must conform to the values type -->
<!ELEMENT xsd:maxInclusive EMPTY>
<!ATTLIST xsd:maxInclusive  value CDATA  #REQUIRED >
<!-- must conform to the values type -->
<!ELEMENT xsd:maxExclusive EMPTY>
<!ATTLIST xsd:maxExclusive  value CDATA  #REQUIRED >
<!-- must conform to the values type -->
<!ELEMENT xsd:length EMPTY>
<!ATTLIST xsd:length  value CDATA  #REQUIRED >
<!-- must be a number -->
<!ELEMENT xsd:minLength EMPTY>
<!ATTLIST xsd:minLength  value CDATA  #REQUIRED >
<!-- must be a number -->
<!ELEMENT xsd:maxLength EMPTY>
<!ATTLIST xsd:maxLength  value CDATA  #REQUIRED >
<!-- must be a number -->
<!ELEMENT xsd:pattern EMPTY>
<!ATTLIST xsd:pattern  value CDATA  #REQUIRED >
<!-- RegEx, must match literals of the value's type -->
<!ELEMENT schema:enumeration  (xsd:enumeration )+>

<!ELEMENT xsd:enumeration EMPTY>
<!ATTLIST xsd:enumeration  value CDATA  #REQUIRED >
