<!--The schema description defines a document type for writing configuration descriptions needed for applications and components.
	The intension of a descriptive format is to achieve a high convertable format. Target formats are XML configuration files and
	LDAP schema and DIT specifications. But it should also be possible to transform this configuration description format to other 
	configuration formats like the gnome format defined by 'gconf'.
	
	Namespaces:
	'schema'	is used for those elements and attributes which are probably only used for the schema specification. They are not part of the transformed format.
	'default'	is used to emphasize those parts of the configuration description, which contains default data.
	'cfg'		is the namespace used in the instance format of the configuration data. 
	'xsd'		is used for elements and attribute which are specified for XML Schema. 
	'xsi'		is the namespace used for instance document within XML Schema.

	LDAP:
	One intension of the format is to allow a specification which may be easily transformed to LDAP. 
	As LDAP needs unique ids for each schema specification (classes and attributes), the configuration specification 
	contains them as well. They are used in the <schema:types> part. To avoid redundance and a ease of definition, the IDs (OID)
	are assembled. An OID contains three parts:
	- OpenOffice organization ID:	Unique ID for OpenOffice, this ID is fixed for the schema
	- Component ID:					Unique ID for the component with the OpenOffice ID range
	- Type ID:						Unique ID for each type definition within the component.
-->
<!--Common attributes of schema nodes - these are also found on instances and therefore in the configuration instance namespace
	'name'	    	is a required attribute, which must be unique within a package (namespace).	
	
	Also common are some (boolean) attributes:
	'finalized'   	specifies whether values in the node (including any subnodes) can ever be changed or overridden
	           	 	by a user. If this is set to 'true' in the schema (as opposed to an administration layer) this means,
					that the tree can only be changed by administrators, but a user without administration rights has
					no the permission to change the tree fragment.
	           		The value of 'finalized' is inherited by subnodes (even subnodes obtained by <instance> expansion).
	           		The default of 'finalized' is 'false'.
	           		As 'finalized' = 'false' propagates to subnodes, it can only be changed to 'true' in node types
	           		other than <schema>.
	'localized'		specifies whether the node has or may have different values for different locales. It may be defined for
					value nodes.					
	'nullable' 		specifies whether it is permissible to have a 'null' (i.e. missing) node.
					The default for 'nullable' is 'true'.
		 			If a non-optional (nullable = 'false') <value> has no default value (given here or by an administrator) it must be
		 			explicitly specified for each user.
					NOTE: 'nullable' is not in NODE-ATTRIBUTES, as it exists only for value nodes.
-->
<!ENTITY % BOOL 'true | false'>
<!ENTITY % BASE-TYPES 'boolean | short | int | long | double | string | binary'>
<!ENTITY % node-attributes ' cfg:name	 	NMTOKEN		#REQUIRED
							 cfg:finalized   	(%BOOL; )  		#IMPLIED'>

<!ENTITY % default-node-attributes ' cfg:name	 	CDATA		#REQUIRED
							 cfg:finalized   	(%BOOL; )  		#IMPLIED'>
<!--  <schema:component>	
	Attributes:
	'cfg:name'		specifies the name of the component. This name must be unique within the package.
	'cfg:package'	is a unique identifier for the component. Package names are composed in a simular to java packages
	'schema:ooOID'  contains the base object id, provided by openoffice.org. Object Ids are necessary for LDAP schema definitions.	
	'schema:category' contains a category for the target schema, categories are 'ApplProfile' or 'UserProfile'
	'xml:lang'		is the default language that applies to all information items

    A <schema:component> node specifies the schema for a particular component of the registry. It is the root element of the 
	component configuration description.	
	A <schema:component> contains three subcatagories of configuation description:
	<schema:types> 		are reusable type definitions within the component.
	<schema:templates>	are nodes (fragments) which are reusable within the configuration containing default data.
	<schema:schema>		describes the actual information tree, which must be present during runtime.	
-->
<!ELEMENT schema:component (schema:documentation?, schema:import*, schema:types?, schema:templates?, schema:schema?)>
<!ATTLIST schema:component
	cfg:name NMTOKEN #REQUIRED
	cfg:package NMTOKEN #REQUIRED
	schema:ooOID CDATA #FIXED "1.3.6.1.4.1.9770.2"
	schema:category CDATA #IMPLIED
	xml:lang NMTOKEN #IMPLIED
	xmlns:schema CDATA #FIXED "http://openoffice.org/2000/registry/schema/description"
	xmlns:default CDATA #FIXED "http://openoffice.org/2000/registry/schema/default"
	xmlns:cfg CDATA #FIXED "http://openoffice.org/2000/registry/instance"
	xmlns:xsd CDATA #FIXED "http://www.w3.org/1999/XMLSchema"
	xmlns:xsi CDATA #FIXED "http://www.w3.org/1999/XMLSchema-instance"
>
<!--This element specifies another schema component that is referenced in this schema 
	The referenced package is given by the 'cfg:component' attribute.
	Types from imported schemas will be needed when value or class specification should be reused.
	The templates from an imported schema will be needed, when <set> entries refer to them.
	The component configuration of an imported package will need to be installed in the configuration database, when 
	when a configuration <uses> it.
-->
<!ELEMENT schema:import EMPTY>
<!ATTLIST schema:import
	cfg:component NMTOKEN #IMPLIED
>

<!--<schema:types>	
	Attributes:
	'component-id'	contains the component object id, typically assembled of a application and the id of the component.
	
	The <schema:types> element contains a list of reusable type definitions. There are two kinds of types. <schema:value>s, 
	which characterize a value given as a base type like string. The other kind are <schema:class> elements. 
	They group a list of schema values as member.
	
	Both kind of type definition must have unique names for the whole configuration schema. This is neccessary to keep the compability to LDAP schema
	definitions. It is also necessary to specify a unique id for each type.	
-->
<!ELEMENT schema:types (schema:value | schema:class)*>
<!ATTLIST schema:types
	schema:component-id CDATA #REQUIRED
>

<!--<schema:value>	
	Attributes:
	'cfg:name'			contains the unique (whole schema, in LDAP sense world wide) name of the value.
	'schema:type-id'	contains the unique id for the type (component wide)
	'schema:external'	specifies, whether this type is already exists within an LDAP schema. 
	'cfg:type'			determines the simple type of the value
	'cfg:derivedBy'		specifies whether this type may have a list of values or not.	
	
	A <schema:value> is used to describe a value (leaf) node of the configuration.
	
	The "cfg:type" attribute specifies the data type of the value.
	
	If the "cfg:derivedBy" attribute is given with the value "list" the data type is "list of [type]".
	Additional information about the data type can be given in a type-info element.	
	
	If "cfg:type" is "string" the "xml:space" attribute can be specified as "preserve" on to force 
	preserving whitespace on all children.
	
	If "cfg:type" is "binary", data of this type will be encoded to "hex" 
	"hex" binaries are transferred as a string which has two hexadecimal digits for each octet.

	If 'type-id' is missing, the value must be declared as external.
-->
<!ELEMENT schema:value (schema:documentation?, schema:type-info?)*>
<!ATTLIST schema:value
	cfg:name NMTOKEN #REQUIRED
	schema:type-id CDATA #IMPLIED
	schema:external (%BOOL;) #IMPLIED
	cfg:type (%BASE-TYPES;) #REQUIRED
	cfg:derivedBy (list) #IMPLIED
	xml:space (default | preserve) #IMPLIED
>

<!--<schema:class>	
	Attributes:
	'cfg:name'			contains the unique (whole schema, in LDAP sense world wide) name of the class.
	'schema:type-id'	contains the unique id for the type (component wide)
	'schema:external'	specifies, whether this type is already exists within an LDAP schema. 
	
	The <schema:class> element composes a group of leaf nodes. These are called member. This kind of specification
	is very similar to LDAP objectclass specifications. 
	Each member specification contains a reference to a previously defined <schema:value>. 
	
	<schema:extension> can be used to inherit class definitions. Inheritance means that a class inherited for
	a super class inherits all member definitions.

	If 'type-id' is missing, the class must be declared as external, IOW it is already defined as a LDAP object class.
-->
<!ELEMENT schema:class (schema:documentation?, schema:extension?, (schema:member+))>
<!ATTLIST schema:class
	cfg:name NMTOKEN #REQUIRED
	schema:type-id CDATA #IMPLIED
	schema:external (%BOOL;) #IMPLIED
>

<!--<schema:extension>	
	Attributes:
	'schema:base'		is the class name from which this class is derived.
	'cfg:component'		is the component, where the base class is defined.
	
	The <schema:extension> describes an inheritance relationship to a base class. Only simple inheritance is allowed.

	The cfg:component defines the component where the base class is defined. If the class is defined
	in the current component, the cfg:component does not need to be defined.
-->
<!ELEMENT schema:extension EMPTY>
<!ATTLIST schema:extension
	schema:base NMTOKEN #REQUIRED
	cfg:component NMTOKEN #IMPLIED
>

<!--<schema:member>	
	Attributes:
	'schema:ref'		is the name of the value, which should be a member of the class.
	'cfg:component'		is the component, where the base class is defined.
	'cfg:nullable'		determines whether the member is mandantory or not.
	
	Members are values which are composed to one class. This concept is very simular to LDAP, where you
	have the same kind of relation between object classes and attributes.
	
	The cfg:component defines the component where the member (schema:value) was defined. If the member is defined
	in the current component, the cfg:component does not need to be defined.
-->
<!ELEMENT schema:member EMPTY>
<!ATTLIST schema:member
	schema:ref NMTOKEN #REQUIRED
	cfg:component NMTOKEN #IMPLIED
	cfg:nullable (%BOOL;) #IMPLIED
>
<!--A <templates> node contains reusable types. 
	IOW, nodes that appear under it, serve as reusable schema fragments.
	Templates that are immediate childs of templates are exported, and can be referenced from other schemas.
	Templates can be <group> and <set> nodes - these define a whole subtree structure - or default:items,
	which are leaf nodes (values)
	They can occur as children of a <set> node that has the template as its template-ref.
-->
<!ELEMENT schema:templates (schema:group | schema:set)*>

<!--A <schema> describes the elements that actually must be present in the configuration for a particular client
	It may contain <uses> elements that specify other (shared) component configurations that also need to be present
	and will be accessed by the client component.
	Often the subtrees of a component configuration will be described as templates. Subtrees corresponding to 
	such templates are specified by <instance> elements. <instance> elements directly contained in a <component>
	should refer only to <group>s and <set>s.
	
	The <schema> may also directly contain <group> or <set> elements, which will not be available as templates.
-->
<!ELEMENT schema:schema (schema:documentation?, schema:uses*, (schema:group | schema:set)+)>
<!ATTLIST schema:schema
	cfg:finalized (%BOOL;) "false"
>
<!--A <uses> element specifies a runtime dependency of the component that owns this configuration component on the
    configuration component that is named by the cfg.component. IOW the executable component being installed relies on
    the presence of those configuration items.    
-->
<!ELEMENT schema:uses EMPTY>
<!ATTLIST schema:uses
	cfg:component NMTOKEN #REQUIRED
>
<!--A <group> is a grouping of several related configuration items. Groups are the elements to structure the configuration
	information tree. A group may contain a reference to a class definition. In this case the group contains the list of 
	value members defined for this class. Default values for thoes elements can be defined with <default:value> elements.	
	Any combination of <group>, <set> nodes may be contained in a <group>	
-->
<!ELEMENT schema:group (schema:documentation?, (schema:group | schema:set | default:value)*)>
<!ATTLIST schema:group
	%node-attributes; 
	schema:ref NMTOKEN #IMPLIED
	cfg:component NMTOKEN #IMPLIED
>

<!ELEMENT default:group (default:group | default:set | default:value)*>
<!ATTLIST default:group
	%default-node-attributes; 
	schema:ref NMTOKEN #IMPLIED
	cfg:component NMTOKEN #IMPLIED
>

<!--A <set> contains an extensible collection of configuration items.
	Each of them must be of the same type and have the same structure,
	this is enforced by having only a template name to describe those elements
	in attribute "template-ref", which must hold the name for a template.
	The cfg:component defines the component where the template was defined. If the template is defined
	in the current component, the cfg:component does not need to be defined.
	With template-ref and 'cfg:component' it is possible do define the XPath representation cfg:component/template-ref.
	Each element will be as if given by a <instance> referring to this same template.
	Such elements can be given as <default:*> children here. 
	The default elements must match the "template-ref" template.

	If the subelements are of type 'default:item', the "template-ref" contains the default template
	'any', which indicates, that any kind of simple types are allowed for the set as element. 'any' is a build in
	template.
-->
<!ELEMENT schema:set (schema:documentation?, (default:group+ | default:set+ | default:item+)?)>
<!ATTLIST schema:set
	%node-attributes; 
	cfg:template-ref NMTOKEN #REQUIRED
	cfg:component NMTOKEN #IMPLIED
>

<!ELEMENT default:set (default:group+ | default:set+ | default:item+)?>
<!ATTLIST default:set
	%default-node-attributes; 
	cfg:template-ref NMTOKEN #REQUIRED
	cfg:component NMTOKEN #IMPLIED
>

<!--A <default:item> is a special value type which can be used within sets. It is a leaf node, which
	may contain any simple type. The intension of those items is to specify extensible property bags, 
	where each item	is a name-value pair.	
	If the "derivedBy" attribute is given with the value "list" the data type is "list of [type]".
	
	Default data is always specified by the <default:data> child element. Omitting a default 
	will generate a default of (null, "" or 0; tried in this order).
	Use the "xsi:null" attribute with the value "true" for explicit specifying a NULL default.

	If "schema:derivedBy" is given as "list", a default may be specified by including a <default:data> child element, containing 
	a <default:data> child with a list of values separated by a whitespace. 
	To use a different separator for the list, "cfg:separator" should be included with 
	the value specifying the separator.	
-->
<!ELEMENT default:item (default:data+)?>
<!ATTLIST default:item
	%default-node-attributes; 
	cfg:type (%BASE-TYPES;) #REQUIRED
	cfg:derivedBy (list) #IMPLIED
	cfg:separator CDATA #IMPLIED
	xml:space (default | preserve) #IMPLIED
>

<!--A <default:value> specifies defaults for value elements given in the configuration information tree. The 
	defautl:value always needs a reference to the type definition of <schema:value> to which it refers.
	
	Default data is always specified by the <default:data> child element. Omitting a default 
	will generate a default of (null, "" or 0; tried in this order).
	Use the "xsi:null" attribute with the value "true" for explicit specifying a NULL default.

	If "schema:derivedBy" is given as "list", a default may be specified by including a <default:data> child element, containing 
	a <default:data> child with a list of values separated by a whitespace. 
	To use a different separator for the list, "cfg:separator" should be included with the value specifying the separator.

	The <default:data> elements can be used for specifying different default values based on locale. 
	This also requires that "localized" is "true". 
	The "xml:lang" attribute on <default:data> should be given only for localized values.
	Multiple <default:data> children must have different languages specified.	
-->
<!ELEMENT default:value (default:data+)?>
<!ATTLIST default:value
	schema:ref NMTOKEN #REQUIRED	
	cfg:component NMTOKEN #IMPLIED
	cfg:separator CDATA #IMPLIED
	cfg:localized NMTOKEN #IMPLIED
	xml:space (default | preserve) #IMPLIED
>

<!ELEMENT default:data (#PCDATA)>
<!ATTLIST default:data
	xml:lang NMTOKEN #IMPLIED
	xsi:null (%BOOL;) "false"
>
<!--Documentation item, can be applied once to (almost) any schema element
	Contains <title> and <description> elements
	If <title> is missing, the naming attribute (often "name") of the element should be used instead.
	
	Both subelements support the xml:lang attribute for specifying localized versions.
	There can be multiple instances of both subelements (in any order).
	Different instances of the same subelement must differ in their language.
	
	Use the xml:space attribute to supply multi-line descriptions.
	Description can support formatted descriptions (e.g. XHTML, OpenOffice.org XML).
 -->
<!ELEMENT schema:documentation (schema:title | schema:description)*>
<!ELEMENT schema:title (#PCDATA)>
<!ATTLIST schema:title
	xml:lang NMTOKEN #IMPLIED
>
<!ELEMENT schema:description ANY>
<!ATTLIST schema:description
	xml:lang NMTOKEN #IMPLIED
	xml:space (default | preserve) "default"
>
<!--A type-info gives additional information about the data type of a value
	It may contain
		a (possibly localized) description
		a <constraints> element which describes the constraints on the value
			(more constraint types may be added in the future),
		a <unit> element, which names the unit of the value
			with text describing the unit and its purpose and usage,
		and a <value-names> element, which maps the permissible values to
			textual names (and a description of the value)
-->
<!ELEMENT schema:type-info (schema:description*, schema:constraints?, schema:unit?, schema:value-names?)*>
<!ELEMENT schema:unit (schema:description*)>
<!ATTLIST schema:unit
	name CDATA #REQUIRED
>
<!ELEMENT schema:value-names (schema:named-value+)>
<!ATTLIST schema:value-names
	combine (single | bitmask | sequence) "single"
>
<!ELEMENT schema:named-value (schema:description*)>
<!ATTLIST schema:named-value
	value CDATA #REQUIRED
	name CDATA #REQUIRED
>
<!ELEMENT schema:constraints (xsd:minInclusive | xsd:minExclusive | xsd:maxInclusive | xsd:maxExclusive | xsd:length | xsd:minLength | xsd:maxLength | xsd:pattern | schema:enumeration)*>
<!ATTLIST schema:constraints
	xmlns:xsd CDATA #FIXED "http://www.w3.org/1999/XMLSchema"
>
<!-- XML Schema constraints -->
<!ELEMENT xsd:minInclusive EMPTY>
<!ATTLIST xsd:minInclusive
	value CDATA #REQUIRED
>
<!-- must conform to the values type -->
<!ELEMENT xsd:minExclusive EMPTY>
<!ATTLIST xsd:minExclusive
	value CDATA #REQUIRED
>
<!-- must conform to the values type -->
<!ELEMENT xsd:maxInclusive EMPTY>
<!ATTLIST xsd:maxInclusive
	value CDATA #REQUIRED
>
<!-- must conform to the values type -->
<!ELEMENT xsd:maxExclusive EMPTY>
<!ATTLIST xsd:maxExclusive
	value CDATA #REQUIRED
>
<!-- must conform to the values type -->
<!ELEMENT xsd:length EMPTY>
<!ATTLIST xsd:length
	value CDATA #REQUIRED
>
<!-- must be a number -->
<!ELEMENT xsd:minLength EMPTY>
<!ATTLIST xsd:minLength
	value CDATA #REQUIRED
>
<!-- must be a number -->
<!ELEMENT xsd:maxLength EMPTY>
<!ATTLIST xsd:maxLength
	value CDATA #REQUIRED
>
<!-- must be a number -->
<!ELEMENT xsd:pattern EMPTY>
<!ATTLIST xsd:pattern
	value CDATA #REQUIRED
>
<!-- RegEx, must match literals of the value's type -->
<!ELEMENT schema:enumeration (xsd:enumeration)+>
<!ELEMENT xsd:enumeration EMPTY>
<!ATTLIST xsd:enumeration
	value CDATA #REQUIRED
>
