#! /usr/bin/perl

use strict;

#- Define full path to unzip command
my $UnzipCommand = "/usr/bin/unzip";

#- Define the default setup file
my $SetupConf = "setup.ins";

#- Define the zipfiles dir (will be the same as of setup.ins)
my $SetupDir = "."; 

#- Define destination directory
my $DestDir = "/usr/lib/openoffice";

while ( $ARGV[0] =~ /^-/ ) {
	$_ = shift;
	if (m/^-d=(\S+)/) {
		$DestDir=$1;
	}
	elsif (m/^-z=(\S+)/) {
		$UnzipCommand=$1;
	}
	elsif (m/^-i=(\S+)/) {
		$SetupConf=$1;
		$SetupDir=$SetupConf;
	        $SetupDir=~ s|/[^/]*$||;
	}
	else {
		print STDERR "$0: Unknown option $_";
	}
}

# Parse enough of <setup.in> to get correct Directory and File sections.
sub ReadSetup($) {
	my ($file) = @_;
    my $e;
    my %entries;
    open FILE,"$file" || die "Can't read setup from $file : $!\n";
    while (<FILE>) {
		if (/^([_A-Za-z]+)\s*([_A-Za-z0-9]+)/) {
			$entries{$1}{$2} = $e = { };
		}
		elsif (/\s*([_A-Za-z]+)\s*=\s*\"?([^;\"]+)\"?;/) {
			$e->{$1} = $2;
		}
    }
    close FILE;
	
	# Expand predefined dirs to de $DestDir variable
	$entries{Directory}{$_} = { HostName => "$DestDir" } foreach
		qw( PREDEFINED_HOMEDIR  PREDEFINED_PROGDIR PREDEFINED_CONFIGDIR );
			
    \%entries;
}

sub DumpEntries(\%$) {
    my $entries = shift;
    my ($basename) = @_;
    my $sections = $entries->{$basename} if $entries->{$basename};
    while (my ($key, $value) = each(%$sections)) {
	print "$basename $key\n";
	$value->{$_} and print "\t$_\t= \"$value->{$_}\";\n"
	    foreach qw(Bitmap Date DefaultDestPath DefaultLanguage
		       Description FadeType FileName fontsDirFile
		       fontsDirGlobalFile fontspath HostName ID Key
		       Languages Name PackedName Path ProcName
		       ProductName ProductVersion Section Text Time
		       Value VendorBitmap);
	$value->{$_} and print "\t$_\t= $value->{$_};\n"
	    foreach qw(ArchiveFiles ArchiveSize BitmapPosX BitmapPoxY
		       Carrier Default Dir DiskNo FileID FontSize
		       Minimal ModuleID NetDir Order ParentID
		       ProfileID RegistryID ScriptVersion Size
		       TextHeight TextWidth UnixRights);
	print "End\n\n";
    }
}

sub GetFullPath {
    my $dirs = shift;
    my ($id) = @_;
	return ( $dirs->{$id}->{ParentID} ? GetFullPath($dirs, $dirs->{$id}->{ParentID}) . "/" : "" )
		   . $dirs->{$id}->{HostName};
}

sub mkpath {
    # Stolen in File::Path
    my($paths, $verbose, $mode) = @_;
    # $paths   -- either a path string or ref to list of paths
    # $verbose -- optional print "mkdir $path" for each directory created
    # $mode    -- optional permissions, defaults to 0777
    local($")= "/";
    $mode = 0777 unless defined($mode);
    $paths = [$paths] unless ref $paths;
    my(@created,$path);
    foreach $path (@$paths) {
        next if -d $path;
	# parent=dirname
        my $parent = $path; $parent =~ s#/[^/]*/?$##;
        unless (-d $parent or $path eq $parent) {
            push(@created,mkpath($parent, $verbose, $mode));
        }
        print "mkdir $path\n" if $verbose;
        unless (mkdir($path,$mode)) {
            my $e = $!;
            # allow for another process to have created it meanwhile
            die "mkdir $path: $e" unless -d $path;
        }
        push(@created, $path);
    }
    @created;
}

# Parse the file and get all entries
die "$0: Can't open $SetupConf\n" if ( ! -r $SetupConf );
my $setup = ReadSetup($SetupConf);
#DumpEntries %$setup, "Directory";
#DumpEntries %$setup, "File";

die "$UnzipCommand not found, please set the full path to the unzip command\n" if
    ( ! -x "$UnzipCommand" );

while (my ($key, $value) = each (%{$setup->{File}})) {
    if ($value->{PackedName}) {
		my $zipfile = "$SetupDir/$value->{PackedName}";
		die "$0: zip file $zipfile not accessible" if
			( ! -r "$zipfile" );
		
		# Find language-specific candidates
		if (($key =~ /_Lang$/) || ($value->{Name} =~ /\.res$/)) {
			print "Unpacking $zipfile... \n";
			# Prefer NetDir path over simple Dir
			my $outpath = GetFullPath \%{$setup->{Directory}}, $value->{NetDir} ? $value->{NetDir} : $value->{Dir};
			-d $outpath or mkpath($outpath);
			system("$UnzipCommand -qq -o $zipfile -d $outpath");
		}
    }
}

